{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __extends } from \"tslib\";\nimport { Amplify, ConsoleLogger as Logger } from '@aws-amplify/core';\nimport { defaultConfig, getCurrTime } from './Utils';\nimport { StorageCache } from './StorageCache';\nvar logger = new Logger('Cache');\n/**\n * Customized storage based on the SessionStorage or LocalStorage with LRU implemented\n */\nvar BrowserStorageCacheClass = /** @class */function (_super) {\n  __extends(BrowserStorageCacheClass, _super);\n  /**\n   * initialize the cache\n   * @param config - the configuration of the cache\n   */\n  function BrowserStorageCacheClass(config) {\n    var _this = this;\n    var cacheConfig = config ? Object.assign({}, defaultConfig, config) : defaultConfig;\n    _this = _super.call(this, cacheConfig) || this;\n    _this.config.storage = cacheConfig.storage;\n    _this.getItem = _this.getItem.bind(_this);\n    _this.setItem = _this.setItem.bind(_this);\n    _this.removeItem = _this.removeItem.bind(_this);\n    return _this;\n  }\n  /**\n   * decrease current size of the cache\n   *\n   * @private\n   * @param amount - the amount of the cache size which needs to be decreased\n   */\n  BrowserStorageCacheClass.prototype._decreaseCurSizeInBytes = function (amount) {\n    var curSize = this.getCacheCurSize();\n    this.config.storage.setItem(this.cacheCurSizeKey, (curSize - amount).toString());\n  };\n  /**\n   * increase current size of the cache\n   *\n   * @private\n   * @param amount - the amount of the cache szie which need to be increased\n   */\n  BrowserStorageCacheClass.prototype._increaseCurSizeInBytes = function (amount) {\n    var curSize = this.getCacheCurSize();\n    this.config.storage.setItem(this.cacheCurSizeKey, (curSize + amount).toString());\n  };\n  /**\n   * update the visited time if item has been visited\n   *\n   * @private\n   * @param item - the item which need to be refreshed\n   * @param prefixedKey - the key of the item\n   *\n   * @return the refreshed item\n   */\n  BrowserStorageCacheClass.prototype._refreshItem = function (item, prefixedKey) {\n    item.visitedTime = getCurrTime();\n    this.config.storage.setItem(prefixedKey, JSON.stringify(item));\n    return item;\n  };\n  /**\n   * check wether item is expired\n   *\n   * @private\n   * @param key - the key of the item\n   *\n   * @return true if the item is expired.\n   */\n  BrowserStorageCacheClass.prototype._isExpired = function (key) {\n    var text = this.config.storage.getItem(key);\n    var item = JSON.parse(text);\n    if (getCurrTime() >= item.expires) {\n      return true;\n    }\n    return false;\n  };\n  /**\n   * delete item from cache\n   *\n   * @private\n   * @param prefixedKey - the key of the item\n   * @param size - optional, the byte size of the item\n   */\n  BrowserStorageCacheClass.prototype._removeItem = function (prefixedKey, size) {\n    var itemSize = size ? size : JSON.parse(this.config.storage.getItem(prefixedKey)).byteSize;\n    this._decreaseCurSizeInBytes(itemSize);\n    // remove the cache item\n    this.config.storage.removeItem(prefixedKey);\n  };\n  /**\n   * put item into cache\n   *\n   * @private\n   * @param prefixedKey - the key of the item\n   * @param itemData - the value of the item\n   * @param itemSizeInBytes - the byte size of the item\n   */\n  BrowserStorageCacheClass.prototype._setItem = function (prefixedKey, item) {\n    // update the cache size\n    this._increaseCurSizeInBytes(item.byteSize);\n    try {\n      this.config.storage.setItem(prefixedKey, JSON.stringify(item));\n    } catch (setItemErr) {\n      // if failed, we need to rollback the cache size\n      this._decreaseCurSizeInBytes(item.byteSize);\n      logger.error(\"Failed to set item \" + setItemErr);\n    }\n  };\n  /**\n   * total space needed when poping out items\n   *\n   * @private\n   * @param itemSize\n   *\n   * @return total space needed\n   */\n  BrowserStorageCacheClass.prototype._sizeToPop = function (itemSize) {\n    var spaceItemNeed = this.getCacheCurSize() + itemSize - this.config.capacityInBytes;\n    var cacheThresholdSpace = (1 - this.config.warningThreshold) * this.config.capacityInBytes;\n    return spaceItemNeed > cacheThresholdSpace ? spaceItemNeed : cacheThresholdSpace;\n  };\n  /**\n   * see whether cache is full\n   *\n   * @private\n   * @param itemSize\n   *\n   * @return true if cache is full\n   */\n  BrowserStorageCacheClass.prototype._isCacheFull = function (itemSize) {\n    return itemSize + this.getCacheCurSize() > this.config.capacityInBytes;\n  };\n  /**\n   * scan the storage and find out all the keys owned by this cache\n   * also clean the expired keys while scanning\n   *\n   * @private\n   *\n   * @return array of keys\n   */\n  BrowserStorageCacheClass.prototype._findValidKeys = function () {\n    var keys = [];\n    var keyInCache = [];\n    // get all keys in Storage\n    for (var i = 0; i < this.config.storage.length; i += 1) {\n      keyInCache.push(this.config.storage.key(i));\n    }\n    // find those items which belong to our cache and also clean those expired items\n    for (var i = 0; i < keyInCache.length; i += 1) {\n      var key = keyInCache[i];\n      if (key.indexOf(this.config.keyPrefix) === 0 && key !== this.cacheCurSizeKey) {\n        if (this._isExpired(key)) {\n          this._removeItem(key);\n        } else {\n          keys.push(key);\n        }\n      }\n    }\n    return keys;\n  };\n  /**\n   * get all the items we have, sort them by their priority,\n   * if priority is same, sort them by their last visited time\n   * pop out items from the low priority (5 is the lowest)\n   *\n   * @private\n   * @param keys - all the keys in this cache\n   * @param sizeToPop - the total size of the items which needed to be poped out\n   */\n  BrowserStorageCacheClass.prototype._popOutItems = function (keys, sizeToPop) {\n    var items = [];\n    var remainedSize = sizeToPop;\n    // get the items from Storage\n    for (var i = 0; i < keys.length; i += 1) {\n      var val = this.config.storage.getItem(keys[i]);\n      if (val != null) {\n        var item = JSON.parse(val);\n        items.push(item);\n      }\n    }\n    // first compare priority\n    // then compare visited time\n    items.sort(function (a, b) {\n      if (a.priority > b.priority) {\n        return -1;\n      } else if (a.priority < b.priority) {\n        return 1;\n      } else {\n        if (a.visitedTime < b.visitedTime) {\n          return -1;\n        } else return 1;\n      }\n    });\n    for (var i = 0; i < items.length; i += 1) {\n      // pop out items until we have enough room for new item\n      this._removeItem(items[i].key, items[i].byteSize);\n      remainedSize -= items[i].byteSize;\n      if (remainedSize <= 0) {\n        return;\n      }\n    }\n  };\n  /**\n   * Set item into cache. You can put number, string, boolean or object.\n   * The cache will first check whether has the same key.\n   * If it has, it will delete the old item and then put the new item in\n   * The cache will pop out items if it is full\n   * You can specify the cache item options. The cache will abort and output a warning:\n   * If the key is invalid\n   * If the size of the item exceeds itemMaxSize.\n   * If the value is undefined\n   * If incorrect cache item configuration\n   * If error happened with browser storage\n   *\n   * @param key - the key of the item\n   * @param value - the value of the item\n   * @param {Object} [options] - optional, the specified meta-data\n   */\n  BrowserStorageCacheClass.prototype.setItem = function (key, value, options) {\n    logger.log(\"Set item: key is \" + key + \", value is \" + value + \" with options: \" + options);\n    var prefixedKey = this.config.keyPrefix + key;\n    // invalid keys\n    if (prefixedKey === this.config.keyPrefix || prefixedKey === this.cacheCurSizeKey) {\n      logger.warn(\"Invalid key: should not be empty or 'CurSize'\");\n      return;\n    }\n    if (typeof value === 'undefined') {\n      logger.warn(\"The value of item should not be undefined!\");\n      return;\n    }\n    var cacheItemOptions = {\n      priority: options && options.priority !== undefined ? options.priority : this.config.defaultPriority,\n      expires: options && options.expires !== undefined ? options.expires : this.config.defaultTTL + getCurrTime()\n    };\n    if (cacheItemOptions.priority < 1 || cacheItemOptions.priority > 5) {\n      logger.warn(\"Invalid parameter: priority due to out or range. It should be within 1 and 5.\");\n      return;\n    }\n    var item = this.fillCacheItem(prefixedKey, value, cacheItemOptions);\n    // check wether this item is too big;\n    if (item.byteSize > this.config.itemMaxSize) {\n      logger.warn(\"Item with key: \" + key + \" you are trying to put into is too big!\");\n      return;\n    }\n    try {\n      // first look into the storage, if it exists, delete it.\n      var val = this.config.storage.getItem(prefixedKey);\n      if (val) {\n        this._removeItem(prefixedKey, JSON.parse(val).byteSize);\n      }\n      // check whether the cache is full\n      if (this._isCacheFull(item.byteSize)) {\n        var validKeys = this._findValidKeys();\n        // check again and then pop out items\n        if (this._isCacheFull(item.byteSize)) {\n          var sizeToPop = this._sizeToPop(item.byteSize);\n          this._popOutItems(validKeys, sizeToPop);\n        }\n      }\n      // put item in the cache\n      // may failed due to storage full\n      this._setItem(prefixedKey, item);\n    } catch (e) {\n      logger.warn(\"setItem failed! \" + e);\n    }\n  };\n  /**\n   * Get item from cache. It will return null if item doesn’t exist or it has been expired.\n   * If you specified callback function in the options,\n   * then the function will be executed if no such item in the cache\n   * and finally put the return value into cache.\n   * Please make sure the callback function will return the value you want to put into the cache.\n   * The cache will abort output a warning:\n   * If the key is invalid\n   * If error happened with browser storage\n   *\n   * @param key - the key of the item\n   * @param {Object} [options] - the options of callback function\n   *\n   * @return - return the value of the item\n   */\n  BrowserStorageCacheClass.prototype.getItem = function (key, options) {\n    logger.log(\"Get item: key is \" + key + \" with options \" + options);\n    var ret = null;\n    var prefixedKey = this.config.keyPrefix + key;\n    if (prefixedKey === this.config.keyPrefix || prefixedKey === this.cacheCurSizeKey) {\n      logger.warn(\"Invalid key: should not be empty or 'CurSize'\");\n      return null;\n    }\n    try {\n      ret = this.config.storage.getItem(prefixedKey);\n      if (ret != null) {\n        if (this._isExpired(prefixedKey)) {\n          // if expired, remove that item and return null\n          this._removeItem(prefixedKey, JSON.parse(ret).byteSize);\n          ret = null;\n        } else {\n          // if not expired, great, return the value and refresh it\n          var item = JSON.parse(ret);\n          item = this._refreshItem(item, prefixedKey);\n          return item.data;\n        }\n      }\n      if (options && options.callback !== undefined) {\n        var val = options.callback();\n        if (val !== null) {\n          this.setItem(key, val, options);\n        }\n        return val;\n      }\n      return null;\n    } catch (e) {\n      logger.warn(\"getItem failed! \" + e);\n      return null;\n    }\n  };\n  /**\n   * remove item from the cache\n   * The cache will abort output a warning:\n   * If error happened with browser storage\n   * @param key - the key of the item\n   */\n  BrowserStorageCacheClass.prototype.removeItem = function (key) {\n    logger.log(\"Remove item: key is \" + key);\n    var prefixedKey = this.config.keyPrefix + key;\n    if (prefixedKey === this.config.keyPrefix || prefixedKey === this.cacheCurSizeKey) {\n      return;\n    }\n    try {\n      var val = this.config.storage.getItem(prefixedKey);\n      if (val) {\n        this._removeItem(prefixedKey, JSON.parse(val).byteSize);\n      }\n    } catch (e) {\n      logger.warn(\"removeItem failed! \" + e);\n    }\n  };\n  /**\n   * clear the entire cache\n   * The cache will abort output a warning:\n   * If error happened with browser storage\n   */\n  BrowserStorageCacheClass.prototype.clear = function () {\n    logger.log(\"Clear Cache\");\n    var keysToRemove = [];\n    for (var i = 0; i < this.config.storage.length; i += 1) {\n      var key = this.config.storage.key(i);\n      if (key.indexOf(this.config.keyPrefix) === 0) {\n        keysToRemove.push(key);\n      }\n    }\n    try {\n      for (var i = 0; i < keysToRemove.length; i += 1) {\n        this.config.storage.removeItem(keysToRemove[i]);\n      }\n    } catch (e) {\n      logger.warn(\"clear failed! \" + e);\n    }\n  };\n  /**\n   * Return all the keys in the cache.\n   *\n   * @return - all keys in the cache\n   */\n  BrowserStorageCacheClass.prototype.getAllKeys = function () {\n    var keys = [];\n    for (var i = 0; i < this.config.storage.length; i += 1) {\n      var key = this.config.storage.key(i);\n      if (key.indexOf(this.config.keyPrefix) === 0 && key !== this.cacheCurSizeKey) {\n        keys.push(key.substring(this.config.keyPrefix.length));\n      }\n    }\n    return keys;\n  };\n  /**\n   * return the current size of the cache\n   *\n   * @return - current size of the cache\n   */\n  BrowserStorageCacheClass.prototype.getCacheCurSize = function () {\n    var ret = this.config.storage.getItem(this.cacheCurSizeKey);\n    if (!ret) {\n      this.config.storage.setItem(this.cacheCurSizeKey, '0');\n      ret = '0';\n    }\n    return Number(ret);\n  };\n  /**\n   * Return a new instance of cache with customized configuration.\n   * @param config - the customized configuration\n   *\n   * @return - new instance of Cache\n   */\n  BrowserStorageCacheClass.prototype.createInstance = function (config) {\n    if (!config.keyPrefix || config.keyPrefix === defaultConfig.keyPrefix) {\n      logger.error('invalid keyPrefix, setting keyPrefix with timeStamp');\n      config.keyPrefix = getCurrTime.toString();\n    }\n    return new BrowserStorageCacheClass(config);\n  };\n  return BrowserStorageCacheClass;\n}(StorageCache);\nexport { BrowserStorageCacheClass };\nexport var BrowserStorageCache = new BrowserStorageCacheClass();\nAmplify.register(BrowserStorageCache);","map":{"version":3,"mappings":"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","names":["Amplify","ConsoleLogger","Logger","defaultConfig","getCurrTime","StorageCache","logger","__extends","config","cacheConfig","Object","assign","_this","storage","getItem","bind","setItem","removeItem","BrowserStorageCacheClass","amount","curSize","getCacheCurSize","cacheCurSizeKey","toString","item","prefixedKey","visitedTime","JSON","stringify","key","text","parse","expires","size","itemSize","byteSize","_decreaseCurSizeInBytes","_increaseCurSizeInBytes","setItemErr","error","spaceItemNeed","capacityInBytes","cacheThresholdSpace","warningThreshold","keys","keyInCache","i","length","push","indexOf","keyPrefix","_isExpired","_removeItem","sizeToPop","items","remainedSize","val","sort","a","b","priority","value","options","log","warn","cacheItemOptions","undefined","defaultPriority","defaultTTL","fillCacheItem","itemMaxSize","_isCacheFull","validKeys","_findValidKeys","_sizeToPop","_popOutItems","_setItem","e","ret","_refreshItem","data","callback","keysToRemove","substring","Number","BrowserStorageCache","register"],"sources":["/Workshop/product-metadata/guidance-for-generating-product-descriptions-with-bedrock/source/frontend/node_modules/@aws-amplify/cache/src/BrowserStorageCache.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n// SPDX-License-Identifier: Apache-2.0\r\n\r\nimport { Amplify, ConsoleLogger as Logger } from '@aws-amplify/core';\r\nimport { defaultConfig, getCurrTime } from './Utils';\r\nimport { StorageCache } from './StorageCache';\r\nimport { ICache, CacheConfig, CacheItem, CacheItemOptions } from './types';\r\n\r\nconst logger = new Logger('Cache');\r\n\r\n/**\r\n * Customized storage based on the SessionStorage or LocalStorage with LRU implemented\r\n */\r\nexport class BrowserStorageCacheClass extends StorageCache implements ICache {\r\n\t/**\r\n\t * initialize the cache\r\n\t * @param config - the configuration of the cache\r\n\t */\r\n\tconstructor(config?: CacheConfig) {\r\n\t\tconst cacheConfig = config\r\n\t\t\t? Object.assign({}, defaultConfig, config)\r\n\t\t\t: defaultConfig;\r\n\t\tsuper(cacheConfig);\r\n\t\tthis.config.storage = cacheConfig.storage;\r\n\t\tthis.getItem = this.getItem.bind(this);\r\n\t\tthis.setItem = this.setItem.bind(this);\r\n\t\tthis.removeItem = this.removeItem.bind(this);\r\n\t}\r\n\r\n\t/**\r\n\t * decrease current size of the cache\r\n\t *\r\n\t * @private\r\n\t * @param amount - the amount of the cache size which needs to be decreased\r\n\t */\r\n\tprivate _decreaseCurSizeInBytes(amount: number): void {\r\n\t\tconst curSize: number = this.getCacheCurSize();\r\n\t\tthis.config.storage.setItem(\r\n\t\t\tthis.cacheCurSizeKey,\r\n\t\t\t(curSize - amount).toString()\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * increase current size of the cache\r\n\t *\r\n\t * @private\r\n\t * @param amount - the amount of the cache szie which need to be increased\r\n\t */\r\n\tprivate _increaseCurSizeInBytes(amount: number): void {\r\n\t\tconst curSize: number = this.getCacheCurSize();\r\n\t\tthis.config.storage.setItem(\r\n\t\t\tthis.cacheCurSizeKey,\r\n\t\t\t(curSize + amount).toString()\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * update the visited time if item has been visited\r\n\t *\r\n\t * @private\r\n\t * @param item - the item which need to be refreshed\r\n\t * @param prefixedKey - the key of the item\r\n\t *\r\n\t * @return the refreshed item\r\n\t */\r\n\tprivate _refreshItem(item: CacheItem, prefixedKey: string): CacheItem {\r\n\t\titem.visitedTime = getCurrTime();\r\n\t\tthis.config.storage.setItem(prefixedKey, JSON.stringify(item));\r\n\t\treturn item;\r\n\t}\r\n\r\n\t/**\r\n\t * check wether item is expired\r\n\t *\r\n\t * @private\r\n\t * @param key - the key of the item\r\n\t *\r\n\t * @return true if the item is expired.\r\n\t */\r\n\tprivate _isExpired(key: string): boolean {\r\n\t\tconst text: string | null = this.config.storage.getItem(key);\r\n\t\tconst item: CacheItem = JSON.parse(text);\r\n\t\tif (getCurrTime() >= item.expires) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * delete item from cache\r\n\t *\r\n\t * @private\r\n\t * @param prefixedKey - the key of the item\r\n\t * @param size - optional, the byte size of the item\r\n\t */\r\n\tprivate _removeItem(prefixedKey: string, size?: number): void {\r\n\t\tconst itemSize: number = size\r\n\t\t\t? size\r\n\t\t\t: JSON.parse(this.config.storage.getItem(prefixedKey)).byteSize;\r\n\t\tthis._decreaseCurSizeInBytes(itemSize);\r\n\t\t// remove the cache item\r\n\t\tthis.config.storage.removeItem(prefixedKey);\r\n\t}\r\n\r\n\t/**\r\n\t * put item into cache\r\n\t *\r\n\t * @private\r\n\t * @param prefixedKey - the key of the item\r\n\t * @param itemData - the value of the item\r\n\t * @param itemSizeInBytes - the byte size of the item\r\n\t */\r\n\tprivate _setItem(prefixedKey: string, item: CacheItem): void {\r\n\t\t// update the cache size\r\n\t\tthis._increaseCurSizeInBytes(item.byteSize);\r\n\r\n\t\ttry {\r\n\t\t\tthis.config.storage.setItem(prefixedKey, JSON.stringify(item));\r\n\t\t} catch (setItemErr) {\r\n\t\t\t// if failed, we need to rollback the cache size\r\n\t\t\tthis._decreaseCurSizeInBytes(item.byteSize);\r\n\t\t\tlogger.error(`Failed to set item ${setItemErr}`);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * total space needed when poping out items\r\n\t *\r\n\t * @private\r\n\t * @param itemSize\r\n\t *\r\n\t * @return total space needed\r\n\t */\r\n\tprivate _sizeToPop(itemSize: number): number {\r\n\t\tconst spaceItemNeed =\r\n\t\t\tthis.getCacheCurSize() + itemSize - this.config.capacityInBytes;\r\n\t\tconst cacheThresholdSpace =\r\n\t\t\t(1 - this.config.warningThreshold) * this.config.capacityInBytes;\r\n\t\treturn spaceItemNeed > cacheThresholdSpace\r\n\t\t\t? spaceItemNeed\r\n\t\t\t: cacheThresholdSpace;\r\n\t}\r\n\r\n\t/**\r\n\t * see whether cache is full\r\n\t *\r\n\t * @private\r\n\t * @param itemSize\r\n\t *\r\n\t * @return true if cache is full\r\n\t */\r\n\tprivate _isCacheFull(itemSize: number): boolean {\r\n\t\treturn itemSize + this.getCacheCurSize() > this.config.capacityInBytes;\r\n\t}\r\n\r\n\t/**\r\n\t * scan the storage and find out all the keys owned by this cache\r\n\t * also clean the expired keys while scanning\r\n\t *\r\n\t * @private\r\n\t *\r\n\t * @return array of keys\r\n\t */\r\n\tprivate _findValidKeys(): string[] {\r\n\t\tconst keys: string[] = [];\r\n\t\tconst keyInCache: string[] = [];\r\n\t\t// get all keys in Storage\r\n\t\tfor (let i = 0; i < this.config.storage.length; i += 1) {\r\n\t\t\tkeyInCache.push(this.config.storage.key(i));\r\n\t\t}\r\n\r\n\t\t// find those items which belong to our cache and also clean those expired items\r\n\t\tfor (let i = 0; i < keyInCache.length; i += 1) {\r\n\t\t\tconst key: string = keyInCache[i];\r\n\t\t\tif (\r\n\t\t\t\tkey.indexOf(this.config.keyPrefix) === 0 &&\r\n\t\t\t\tkey !== this.cacheCurSizeKey\r\n\t\t\t) {\r\n\t\t\t\tif (this._isExpired(key)) {\r\n\t\t\t\t\tthis._removeItem(key);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tkeys.push(key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn keys;\r\n\t}\r\n\r\n\t/**\r\n\t * get all the items we have, sort them by their priority,\r\n\t * if priority is same, sort them by their last visited time\r\n\t * pop out items from the low priority (5 is the lowest)\r\n\t *\r\n\t * @private\r\n\t * @param keys - all the keys in this cache\r\n\t * @param sizeToPop - the total size of the items which needed to be poped out\r\n\t */\r\n\tprivate _popOutItems(keys: string[], sizeToPop: number): void {\r\n\t\tconst items: CacheItem[] = [];\r\n\t\tlet remainedSize: number = sizeToPop;\r\n\t\t// get the items from Storage\r\n\t\tfor (let i = 0; i < keys.length; i += 1) {\r\n\t\t\tconst val: string | null = this.config.storage.getItem(keys[i]);\r\n\t\t\tif (val != null) {\r\n\t\t\t\tconst item: CacheItem = JSON.parse(val);\r\n\t\t\t\titems.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// first compare priority\r\n\t\t// then compare visited time\r\n\t\titems.sort((a, b) => {\r\n\t\t\tif (a.priority > b.priority) {\r\n\t\t\t\treturn -1;\r\n\t\t\t} else if (a.priority < b.priority) {\r\n\t\t\t\treturn 1;\r\n\t\t\t} else {\r\n\t\t\t\tif (a.visitedTime < b.visitedTime) {\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t} else return 1;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tfor (let i = 0; i < items.length; i += 1) {\r\n\t\t\t// pop out items until we have enough room for new item\r\n\t\t\tthis._removeItem(items[i].key, items[i].byteSize);\r\n\t\t\tremainedSize -= items[i].byteSize;\r\n\t\t\tif (remainedSize <= 0) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Set item into cache. You can put number, string, boolean or object.\r\n\t * The cache will first check whether has the same key.\r\n\t * If it has, it will delete the old item and then put the new item in\r\n\t * The cache will pop out items if it is full\r\n\t * You can specify the cache item options. The cache will abort and output a warning:\r\n\t * If the key is invalid\r\n\t * If the size of the item exceeds itemMaxSize.\r\n\t * If the value is undefined\r\n\t * If incorrect cache item configuration\r\n\t * If error happened with browser storage\r\n\t *\r\n\t * @param key - the key of the item\r\n\t * @param value - the value of the item\r\n\t * @param {Object} [options] - optional, the specified meta-data\r\n\t */\r\n\tpublic setItem(\r\n\t\tkey: string,\r\n\t\tvalue: object | number | string | boolean,\r\n\t\toptions?: CacheItemOptions\r\n\t): void {\r\n\t\tlogger.log(\r\n\t\t\t`Set item: key is ${key}, value is ${value} with options: ${options}`\r\n\t\t);\r\n\t\tconst prefixedKey: string = this.config.keyPrefix + key;\r\n\t\t// invalid keys\r\n\t\tif (\r\n\t\t\tprefixedKey === this.config.keyPrefix ||\r\n\t\t\tprefixedKey === this.cacheCurSizeKey\r\n\t\t) {\r\n\t\t\tlogger.warn(`Invalid key: should not be empty or 'CurSize'`);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (typeof value === 'undefined') {\r\n\t\t\tlogger.warn(`The value of item should not be undefined!`);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst cacheItemOptions: CacheItemOptions = {\r\n\t\t\tpriority:\r\n\t\t\t\toptions && options.priority !== undefined\r\n\t\t\t\t\t? options.priority\r\n\t\t\t\t\t: this.config.defaultPriority,\r\n\t\t\texpires:\r\n\t\t\t\toptions && options.expires !== undefined\r\n\t\t\t\t\t? options.expires\r\n\t\t\t\t\t: this.config.defaultTTL + getCurrTime(),\r\n\t\t};\r\n\r\n\t\tif (cacheItemOptions.priority < 1 || cacheItemOptions.priority > 5) {\r\n\t\t\tlogger.warn(\r\n\t\t\t\t`Invalid parameter: priority due to out or range. It should be within 1 and 5.`\r\n\t\t\t);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst item: CacheItem = this.fillCacheItem(\r\n\t\t\tprefixedKey,\r\n\t\t\tvalue,\r\n\t\t\tcacheItemOptions\r\n\t\t);\r\n\r\n\t\t// check wether this item is too big;\r\n\t\tif (item.byteSize > this.config.itemMaxSize) {\r\n\t\t\tlogger.warn(\r\n\t\t\t\t`Item with key: ${key} you are trying to put into is too big!`\r\n\t\t\t);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\t// first look into the storage, if it exists, delete it.\r\n\t\t\tconst val: string | null = this.config.storage.getItem(prefixedKey);\r\n\t\t\tif (val) {\r\n\t\t\t\tthis._removeItem(prefixedKey, JSON.parse(val).byteSize);\r\n\t\t\t}\r\n\r\n\t\t\t// check whether the cache is full\r\n\t\t\tif (this._isCacheFull(item.byteSize)) {\r\n\t\t\t\tconst validKeys: string[] = this._findValidKeys();\r\n\t\t\t\t// check again and then pop out items\r\n\t\t\t\tif (this._isCacheFull(item.byteSize)) {\r\n\t\t\t\t\tconst sizeToPop: number = this._sizeToPop(item.byteSize);\r\n\t\t\t\t\tthis._popOutItems(validKeys, sizeToPop);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// put item in the cache\r\n\t\t\t// may failed due to storage full\r\n\t\t\tthis._setItem(prefixedKey, item);\r\n\t\t} catch (e) {\r\n\t\t\tlogger.warn(`setItem failed! ${e}`);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Get item from cache. It will return null if item doesn’t exist or it has been expired.\r\n\t * If you specified callback function in the options,\r\n\t * then the function will be executed if no such item in the cache\r\n\t * and finally put the return value into cache.\r\n\t * Please make sure the callback function will return the value you want to put into the cache.\r\n\t * The cache will abort output a warning:\r\n\t * If the key is invalid\r\n\t * If error happened with browser storage\r\n\t *\r\n\t * @param key - the key of the item\r\n\t * @param {Object} [options] - the options of callback function\r\n\t *\r\n\t * @return - return the value of the item\r\n\t */\r\n\tpublic getItem(key: string, options?: CacheItemOptions): any {\r\n\t\tlogger.log(`Get item: key is ${key} with options ${options}`);\r\n\t\tlet ret: string | null = null;\r\n\t\tconst prefixedKey: string = this.config.keyPrefix + key;\r\n\r\n\t\tif (\r\n\t\t\tprefixedKey === this.config.keyPrefix ||\r\n\t\t\tprefixedKey === this.cacheCurSizeKey\r\n\t\t) {\r\n\t\t\tlogger.warn(`Invalid key: should not be empty or 'CurSize'`);\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tret = this.config.storage.getItem(prefixedKey);\r\n\t\t\tif (ret != null) {\r\n\t\t\t\tif (this._isExpired(prefixedKey)) {\r\n\t\t\t\t\t// if expired, remove that item and return null\r\n\t\t\t\t\tthis._removeItem(prefixedKey, JSON.parse(ret).byteSize);\r\n\t\t\t\t\tret = null;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// if not expired, great, return the value and refresh it\r\n\t\t\t\t\tlet item: CacheItem = JSON.parse(ret);\r\n\t\t\t\t\titem = this._refreshItem(item, prefixedKey);\r\n\t\t\t\t\treturn item.data;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (options && options.callback !== undefined) {\r\n\t\t\t\tconst val: object | string | number | boolean = options.callback();\r\n\t\t\t\tif (val !== null) {\r\n\t\t\t\t\tthis.setItem(key, val, options);\r\n\t\t\t\t}\r\n\t\t\t\treturn val;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t} catch (e) {\r\n\t\t\tlogger.warn(`getItem failed! ${e}`);\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * remove item from the cache\r\n\t * The cache will abort output a warning:\r\n\t * If error happened with browser storage\r\n\t * @param key - the key of the item\r\n\t */\r\n\tpublic removeItem(key: string): void {\r\n\t\tlogger.log(`Remove item: key is ${key}`);\r\n\t\tconst prefixedKey: string = this.config.keyPrefix + key;\r\n\r\n\t\tif (\r\n\t\t\tprefixedKey === this.config.keyPrefix ||\r\n\t\t\tprefixedKey === this.cacheCurSizeKey\r\n\t\t) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tconst val: string | null = this.config.storage.getItem(prefixedKey);\r\n\t\t\tif (val) {\r\n\t\t\t\tthis._removeItem(prefixedKey, JSON.parse(val).byteSize);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tlogger.warn(`removeItem failed! ${e}`);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * clear the entire cache\r\n\t * The cache will abort output a warning:\r\n\t * If error happened with browser storage\r\n\t */\r\n\tpublic clear(): void {\r\n\t\tlogger.log(`Clear Cache`);\r\n\t\tconst keysToRemove: string[] = [];\r\n\r\n\t\tfor (let i = 0; i < this.config.storage.length; i += 1) {\r\n\t\t\tconst key = this.config.storage.key(i);\r\n\t\t\tif (key.indexOf(this.config.keyPrefix) === 0) {\r\n\t\t\t\tkeysToRemove.push(key);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tfor (let i = 0; i < keysToRemove.length; i += 1) {\r\n\t\t\t\tthis.config.storage.removeItem(keysToRemove[i]);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tlogger.warn(`clear failed! ${e}`);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Return all the keys in the cache.\r\n\t *\r\n\t * @return - all keys in the cache\r\n\t */\r\n\tpublic getAllKeys(): string[] {\r\n\t\tconst keys: string[] = [];\r\n\t\tfor (let i = 0; i < this.config.storage.length; i += 1) {\r\n\t\t\tconst key = this.config.storage.key(i);\r\n\t\t\tif (\r\n\t\t\t\tkey.indexOf(this.config.keyPrefix) === 0 &&\r\n\t\t\t\tkey !== this.cacheCurSizeKey\r\n\t\t\t) {\r\n\t\t\t\tkeys.push(key.substring(this.config.keyPrefix.length));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn keys;\r\n\t}\r\n\r\n\t/**\r\n\t * return the current size of the cache\r\n\t *\r\n\t * @return - current size of the cache\r\n\t */\r\n\tpublic getCacheCurSize(): number {\r\n\t\tlet ret: string | null = this.config.storage.getItem(this.cacheCurSizeKey);\r\n\t\tif (!ret) {\r\n\t\t\tthis.config.storage.setItem(this.cacheCurSizeKey, '0');\r\n\t\t\tret = '0';\r\n\t\t}\r\n\t\treturn Number(ret);\r\n\t}\r\n\r\n\t/**\r\n\t * Return a new instance of cache with customized configuration.\r\n\t * @param config - the customized configuration\r\n\t *\r\n\t * @return - new instance of Cache\r\n\t */\r\n\tpublic createInstance(config: CacheConfig): ICache {\r\n\t\tif (!config.keyPrefix || config.keyPrefix === defaultConfig.keyPrefix) {\r\n\t\t\tlogger.error('invalid keyPrefix, setting keyPrefix with timeStamp');\r\n\t\t\tconfig.keyPrefix = getCurrTime.toString();\r\n\t\t}\r\n\r\n\t\treturn new BrowserStorageCacheClass(config);\r\n\t}\r\n}\r\n\r\nexport const BrowserStorageCache: ICache = new BrowserStorageCacheClass();\r\n\r\nAmplify.register(BrowserStorageCache);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}