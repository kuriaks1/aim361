{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __rest } from \"tslib\";\nimport { ModelPredicateCreator } from '../predicates';\nimport { QueryOne } from '../types';\nimport { USER, SYNC, valuesEqual } from '../util';\nimport { getIdentifierValue, TransformerMutationType } from './utils';\n// TODO: Persist deleted ids\n// https://github.com/aws-amplify/amplify-js/blob/datastore-docs/packages/datastore/docs/sync-engine.md#outbox\nvar MutationEventOutbox = /** @class */function () {\n  function MutationEventOutbox(schema, MutationEvent, modelInstanceCreator, ownSymbol) {\n    this.schema = schema;\n    this.MutationEvent = MutationEvent;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.ownSymbol = ownSymbol;\n  }\n  MutationEventOutbox.prototype.enqueue = function (storage, mutationEvent) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, storage.runExclusive(function (s) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var mutationEventModelDefinition, predicate, _a, first, incomingMutationType, merged_1, incomingConditionJSON, incomingCondition, merged;\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      mutationEventModelDefinition = this.schema.namespaces[SYNC].models['MutationEvent'];\n                      predicate = ModelPredicateCreator.createFromAST(mutationEventModelDefinition, {\n                        and: [{\n                          modelId: {\n                            eq: mutationEvent.modelId\n                          }\n                        }, {\n                          id: {\n                            ne: this.inProgressMutationEventId\n                          }\n                        }]\n                      });\n                      return [4 /*yield*/, s.query(this.MutationEvent, predicate)];\n                    case 1:\n                      _a = __read.apply(void 0, [_b.sent(), 1]), first = _a[0];\n                      if (!(first === undefined)) return [3 /*break*/, 3];\n                      return [4 /*yield*/, s.save(mutationEvent, undefined, this.ownSymbol)];\n                    case 2:\n                      _b.sent();\n                      return [2 /*return*/];\n                    case 3:\n                      incomingMutationType = mutationEvent.operation;\n                      if (!(first.operation === TransformerMutationType.CREATE)) return [3 /*break*/, 8];\n                      if (!(incomingMutationType === TransformerMutationType.DELETE)) return [3 /*break*/, 5];\n                      return [4 /*yield*/, s.delete(this.MutationEvent, predicate)];\n                    case 4:\n                      _b.sent();\n                      return [3 /*break*/, 7];\n                    case 5:\n                      merged_1 = this.mergeUserFields(first, mutationEvent);\n                      return [4 /*yield*/, s.save(this.MutationEvent.copyOf(first, function (draft) {\n                        draft.data = merged_1.data;\n                      }), undefined, this.ownSymbol)];\n                    case 6:\n                      _b.sent();\n                      _b.label = 7;\n                    case 7:\n                      return [3 /*break*/, 12];\n                    case 8:\n                      incomingConditionJSON = mutationEvent.condition;\n                      incomingCondition = JSON.parse(incomingConditionJSON);\n                      merged = void 0;\n                      if (!(Object.keys(incomingCondition).length === 0)) return [3 /*break*/, 10];\n                      merged = this.mergeUserFields(first, mutationEvent);\n                      // delete all for model\n                      return [4 /*yield*/, s.delete(this.MutationEvent, predicate)];\n                    case 9:\n                      // delete all for model\n                      _b.sent();\n                      _b.label = 10;\n                    case 10:\n                      merged = merged || mutationEvent;\n                      // Enqueue new one\n                      return [4 /*yield*/, s.save(merged, undefined, this.ownSymbol)];\n                    case 11:\n                      // Enqueue new one\n                      _b.sent();\n                      _b.label = 12;\n                    case 12:\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            })];\n\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  MutationEventOutbox.prototype.dequeue = function (storage, record, recordOp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var head;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.peek(storage)];\n          case 1:\n            head = _a.sent();\n            if (!record) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.syncOutboxVersionsOnDequeue(storage, record, head, recordOp)];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            return [4 /*yield*/, storage.delete(head)];\n          case 4:\n            _a.sent();\n            this.inProgressMutationEventId = undefined;\n            return [2 /*return*/, head];\n        }\n      });\n    });\n  };\n  /**\n   * Doing a peek() implies that the mutation goes \"inProgress\"\n   *\n   * @param storage\n   */\n  MutationEventOutbox.prototype.peek = function (storage) {\n    return __awaiter(this, void 0, void 0, function () {\n      var head;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, storage.queryOne(this.MutationEvent, QueryOne.FIRST)];\n          case 1:\n            head = _a.sent();\n            this.inProgressMutationEventId = head ? head.id : undefined;\n            return [2 /*return*/, head];\n        }\n      });\n    });\n  };\n  MutationEventOutbox.prototype.getForModel = function (storage, model, userModelDefinition) {\n    return __awaiter(this, void 0, void 0, function () {\n      var mutationEventModelDefinition, modelId, mutationEvents;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            mutationEventModelDefinition = this.schema.namespaces[SYNC].models.MutationEvent;\n            modelId = getIdentifierValue(userModelDefinition, model);\n            return [4 /*yield*/, storage.query(this.MutationEvent, ModelPredicateCreator.createFromAST(mutationEventModelDefinition, {\n              and: {\n                modelId: {\n                  eq: modelId\n                }\n              }\n            }))];\n          case 1:\n            mutationEvents = _a.sent();\n            return [2 /*return*/, mutationEvents];\n        }\n      });\n    });\n  };\n  MutationEventOutbox.prototype.getModelIds = function (storage) {\n    return __awaiter(this, void 0, void 0, function () {\n      var mutationEvents, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, storage.query(this.MutationEvent)];\n          case 1:\n            mutationEvents = _a.sent();\n            result = new Set();\n            mutationEvents.forEach(function (_a) {\n              var modelId = _a.modelId;\n              return result.add(modelId);\n            });\n            return [2 /*return*/, result];\n        }\n      });\n    });\n  };\n  // applies _version from the AppSync mutation response to other items\n  // in the mutation queue with the same id\n  // see https://github.com/aws-amplify/amplify-js/pull/7354 for more details\n  MutationEventOutbox.prototype.syncOutboxVersionsOnDequeue = function (storage, record, head, recordOp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _version, _lastChangedAt, _deleted, _incomingData, incomingData, data, __version, __lastChangedAt, __deleted, _outgoingData, outgoingData, mutationEventModelDefinition, userModelDefinition, recordId, predicate, outdatedMutations, reconciledMutations;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (head.operation !== recordOp) {\n              return [2 /*return*/];\n            }\n\n            _version = record._version, _lastChangedAt = record._lastChangedAt, _deleted = record._deleted, _incomingData = __rest(record, [\"_version\", \"_lastChangedAt\", \"_deleted\"]);\n            incomingData = this.removeTimestampFields(head.model, _incomingData);\n            data = JSON.parse(head.data);\n            if (!data) {\n              return [2 /*return*/];\n            }\n\n            __version = data._version, __lastChangedAt = data._lastChangedAt, __deleted = data._deleted, _outgoingData = __rest(data, [\"_version\", \"_lastChangedAt\", \"_deleted\"]);\n            outgoingData = this.removeTimestampFields(head.model, _outgoingData);\n            // Don't sync the version when the data in the response does not match the data\n            // in the request, i.e., when there's a handled conflict\n            //\n            // NOTE: `incomingData` contains all the fields in the record, and `outgoingData`\n            // only contains updated fields, resulting in an error when doing a comparison\n            // of two equal mutations. Fix this, or mitigate otherwise.\n            if (!valuesEqual(incomingData, outgoingData, true)) {\n              return [2 /*return*/];\n            }\n\n            mutationEventModelDefinition = this.schema.namespaces[SYNC].models['MutationEvent'];\n            userModelDefinition = this.schema.namespaces['user'].models[head.model];\n            recordId = getIdentifierValue(userModelDefinition, record);\n            predicate = ModelPredicateCreator.createFromAST(mutationEventModelDefinition, {\n              and: [{\n                modelId: {\n                  eq: recordId\n                }\n              }, {\n                id: {\n                  ne: this.inProgressMutationEventId\n                }\n              }]\n            });\n            return [4 /*yield*/, storage.query(this.MutationEvent, predicate)];\n          case 1:\n            outdatedMutations = _a.sent();\n            if (!outdatedMutations.length) {\n              return [2 /*return*/];\n            }\n\n            reconciledMutations = outdatedMutations.map(function (m) {\n              var oldData = JSON.parse(m.data);\n              var newData = __assign(__assign({}, oldData), {\n                _version: _version,\n                _lastChangedAt: _lastChangedAt\n              });\n              return _this.MutationEvent.copyOf(m, function (draft) {\n                draft.data = JSON.stringify(newData);\n              });\n            });\n            return [4 /*yield*/, storage.delete(this.MutationEvent, predicate)];\n          case 2:\n            _a.sent();\n            return [4 /*yield*/, Promise.all(reconciledMutations.map(function (m) {\n              return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4 /*yield*/, storage.save(m, undefined, this.ownSymbol)];\n                    case 1:\n                      return [2 /*return*/, _a.sent()];\n                  }\n                });\n              });\n            }))];\n          case 3:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  MutationEventOutbox.prototype.mergeUserFields = function (previous, current) {\n    var _a = JSON.parse(previous.data),\n      _version = _a._version,\n      _lastChangedAt = _a._lastChangedAt,\n      _deleted = _a._deleted,\n      previousData = __rest(_a, [\"_version\", \"_lastChangedAt\", \"_deleted\"]);\n    var _b = JSON.parse(current.data),\n      __version = _b._version,\n      __lastChangedAt = _b._lastChangedAt,\n      __deleted = _b._deleted,\n      currentData = __rest(_b, [\"_version\", \"_lastChangedAt\", \"_deleted\"]);\n    var data = JSON.stringify(__assign(__assign({\n      _version: _version,\n      _lastChangedAt: _lastChangedAt,\n      _deleted: _deleted\n    }, previousData), currentData));\n    return this.modelInstanceCreator(this.MutationEvent, __assign(__assign({}, current), {\n      data: data\n    }));\n  };\n  /*\n  if a model is using custom timestamp fields\n  the custom field names will be stored in the model attributes\n   e.g.\n  \"attributes\": [\n  {\n          \"type\": \"model\",\n          \"properties\": {\n              \"timestamps\": {\n                  \"createdAt\": \"createdOn\",\n                  \"updatedAt\": \"updatedOn\"\n              }\n          }\n  }\n  ]\n  */\n  MutationEventOutbox.prototype.removeTimestampFields = function (model, record) {\n    var _a, _b;\n    var CREATED_AT_DEFAULT_KEY = 'createdAt';\n    var UPDATED_AT_DEFAULT_KEY = 'updatedAt';\n    var createdTimestampKey = CREATED_AT_DEFAULT_KEY;\n    var updatedTimestampKey = UPDATED_AT_DEFAULT_KEY;\n    var modelAttributes = (_a = this.schema.namespaces[USER].models[model].attributes) === null || _a === void 0 ? void 0 : _a.find(function (attr) {\n      return attr.type === 'model';\n    });\n    var timestampFieldsMap = (_b = modelAttributes === null || modelAttributes === void 0 ? void 0 : modelAttributes.properties) === null || _b === void 0 ? void 0 : _b.timestamps;\n    if (timestampFieldsMap) {\n      createdTimestampKey = timestampFieldsMap[CREATED_AT_DEFAULT_KEY];\n      updatedTimestampKey = timestampFieldsMap[UPDATED_AT_DEFAULT_KEY];\n    }\n    delete record[createdTimestampKey];\n    delete record[updatedTimestampKey];\n    return record;\n  };\n  return MutationEventOutbox;\n}();\nexport { MutationEventOutbox };","map":{"version":3,"mappings":"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","names":["ModelPredicateCreator","QueryOne","USER","SYNC","valuesEqual","getIdentifierValue","TransformerMutationType","schema","MutationEvent","modelInstanceCreator","ownSymbol","MutationEventOutbox","storage","mutationEvent","runExclusive","s","mutationEventModelDefinition","namespaces","models","predicate","createFromAST","and","modelId","eq","id","ne","inProgressMutationEventId","query","_a","_b","first","undefined","save","incomingMutationType","operation","CREATE","DELETE","delete","merged_1","mergeUserFields","copyOf","draft","data","incomingConditionJSON","incomingCondition","JSON","parse","merged","Object","keys","length","record","recordOp","peek","head","syncOutboxVersionsOnDequeue","queryOne","FIRST","model","userModelDefinition","mutationEvents","result","Set","forEach","add","_version","_lastChangedAt","_deleted","_incomingData","incomingData","removeTimestampFields","__version","__lastChangedAt","__deleted","_outgoingData","outgoingData","recordId","outdatedMutations","reconciledMutations","map","oldData","m","newData","_this","stringify","Promise","all","previous","current","previousData","currentData","CREATED_AT_DEFAULT_KEY","UPDATED_AT_DEFAULT_KEY","createdTimestampKey","updatedTimestampKey","modelAttributes","attributes","find","type","timestampFieldsMap","properties","timestamps"],"sources":["/Workshop/product-metadata/guidance-for-generating-product-descriptions-with-bedrock/source/frontend/node_modules/@aws-amplify/datastore/src/sync/outbox.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { MutationEvent } from './index';\nimport { ModelPredicateCreator } from '../predicates';\nimport {\n\tExclusiveStorage as Storage,\n\tStorageFacade,\n\tStorage as StorageClass,\n} from '../storage/storage';\nimport { ModelInstanceCreator } from '../datastore/datastore';\nimport {\n\tInternalSchema,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tQueryOne,\n\tSchemaModel,\n} from '../types';\nimport { USER, SYNC, valuesEqual } from '../util';\nimport { getIdentifierValue, TransformerMutationType } from './utils';\n\n// TODO: Persist deleted ids\n// https://github.com/aws-amplify/amplify-js/blob/datastore-docs/packages/datastore/docs/sync-engine.md#outbox\nclass MutationEventOutbox {\n\tprivate inProgressMutationEventId!: string;\n\n\tconstructor(\n\t\tprivate readonly schema: InternalSchema,\n\t\tprivate readonly MutationEvent: PersistentModelConstructor<MutationEvent>,\n\t\tprivate readonly modelInstanceCreator: ModelInstanceCreator,\n\t\tprivate readonly ownSymbol: Symbol\n\t) {}\n\n\tpublic async enqueue(\n\t\tstorage: Storage,\n\t\tmutationEvent: MutationEvent\n\t): Promise<void> {\n\t\tawait storage.runExclusive(async s => {\n\t\t\tconst mutationEventModelDefinition =\n\t\t\t\tthis.schema.namespaces[SYNC].models['MutationEvent'];\n\n\t\t\t// `id` is the key for the record in the mutationEvent;\n\t\t\t// `modelId` is the key for the actual record that was mutated\n\t\t\tconst predicate = ModelPredicateCreator.createFromAST<MutationEvent>(\n\t\t\t\tmutationEventModelDefinition,\n\t\t\t\t{\n\t\t\t\t\tand: [\n\t\t\t\t\t\t{ modelId: { eq: mutationEvent.modelId } },\n\t\t\t\t\t\t{ id: { ne: this.inProgressMutationEventId } },\n\t\t\t\t\t],\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// Check if there are any other records with same id\n\t\t\tconst [first] = await s.query(this.MutationEvent, predicate);\n\n\t\t\t// No other record with same modelId, so enqueue\n\t\t\tif (first === undefined) {\n\t\t\t\tawait s.save(mutationEvent, undefined, this.ownSymbol);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// There was an enqueued mutation for the modelId, so continue\n\t\t\tconst { operation: incomingMutationType } = mutationEvent;\n\n\t\t\tif (first.operation === TransformerMutationType.CREATE) {\n\t\t\t\tif (incomingMutationType === TransformerMutationType.DELETE) {\n\t\t\t\t\tawait s.delete(this.MutationEvent, predicate);\n\t\t\t\t} else {\n\t\t\t\t\t// first gets updated with the incoming mutation's data, condition intentionally skipped\n\n\t\t\t\t\t// we need to merge the fields for a create and update mutation to prevent\n\t\t\t\t\t// data loss, since update mutations only include changed fields\n\t\t\t\t\tconst merged = this.mergeUserFields(first, mutationEvent);\n\t\t\t\t\tawait s.save(\n\t\t\t\t\t\tthis.MutationEvent.copyOf(first, draft => {\n\t\t\t\t\t\t\tdraft.data = merged.data;\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tthis.ownSymbol\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst { condition: incomingConditionJSON } = mutationEvent;\n\t\t\t\tconst incomingCondition = JSON.parse(incomingConditionJSON);\n\t\t\t\tlet merged: MutationEvent;\n\n\t\t\t\t// If no condition\n\t\t\t\tif (Object.keys(incomingCondition).length === 0) {\n\t\t\t\t\tmerged = this.mergeUserFields(first, mutationEvent);\n\n\t\t\t\t\t// delete all for model\n\t\t\t\t\tawait s.delete(this.MutationEvent, predicate);\n\t\t\t\t}\n\n\t\t\t\tmerged = merged! || mutationEvent;\n\n\t\t\t\t// Enqueue new one\n\t\t\t\tawait s.save(merged, undefined, this.ownSymbol);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic async dequeue(\n\t\tstorage: StorageClass,\n\t\trecord?: PersistentModel,\n\t\trecordOp?: TransformerMutationType\n\t): Promise<MutationEvent> {\n\t\tconst head = await this.peek(storage);\n\n\t\tif (record) {\n\t\t\tawait this.syncOutboxVersionsOnDequeue(storage, record, head, recordOp!);\n\t\t}\n\n\t\tawait storage.delete(head);\n\t\tthis.inProgressMutationEventId = undefined!;\n\n\t\treturn head;\n\t}\n\n\t/**\n\t * Doing a peek() implies that the mutation goes \"inProgress\"\n\t *\n\t * @param storage\n\t */\n\tpublic async peek(storage: StorageFacade): Promise<MutationEvent> {\n\t\tconst head = await storage.queryOne(this.MutationEvent, QueryOne.FIRST);\n\n\t\tthis.inProgressMutationEventId = head ? head.id : undefined!;\n\n\t\treturn head!;\n\t}\n\n\tpublic async getForModel<T extends PersistentModel>(\n\t\tstorage: StorageFacade,\n\t\tmodel: T,\n\t\tuserModelDefinition: SchemaModel\n\t): Promise<MutationEvent[]> {\n\t\tconst mutationEventModelDefinition =\n\t\t\tthis.schema.namespaces[SYNC].models.MutationEvent;\n\n\t\tconst modelId = getIdentifierValue(userModelDefinition, model);\n\n\t\tconst mutationEvents = await storage.query(\n\t\t\tthis.MutationEvent,\n\t\t\tModelPredicateCreator.createFromAST(mutationEventModelDefinition, {\n\t\t\t\tand: { modelId: { eq: modelId } },\n\t\t\t})\n\t\t);\n\n\t\treturn mutationEvents;\n\t}\n\n\tpublic async getModelIds(storage: StorageFacade): Promise<Set<string>> {\n\t\tconst mutationEvents = await storage.query(this.MutationEvent);\n\n\t\tconst result = new Set<string>();\n\n\t\tmutationEvents.forEach(({ modelId }) => result.add(modelId));\n\n\t\treturn result;\n\t}\n\n\t// applies _version from the AppSync mutation response to other items\n\t// in the mutation queue with the same id\n\t// see https://github.com/aws-amplify/amplify-js/pull/7354 for more details\n\tprivate async syncOutboxVersionsOnDequeue(\n\t\tstorage: StorageClass,\n\t\trecord: PersistentModel,\n\t\thead: PersistentModel,\n\t\trecordOp: string\n\t): Promise<void> {\n\t\tif (head.operation !== recordOp) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { _version, _lastChangedAt, _deleted, ..._incomingData } = record;\n\t\tconst incomingData = this.removeTimestampFields(head.model, _incomingData);\n\n\t\tconst data = JSON.parse(head.data);\n\n\t\tif (!data) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst {\n\t\t\t_version: __version,\n\t\t\t_lastChangedAt: __lastChangedAt,\n\t\t\t_deleted: __deleted,\n\t\t\t..._outgoingData\n\t\t} = data;\n\t\tconst outgoingData = this.removeTimestampFields(head.model, _outgoingData);\n\n\t\t// Don't sync the version when the data in the response does not match the data\n\t\t// in the request, i.e., when there's a handled conflict\n\t\t//\n\t\t// NOTE: `incomingData` contains all the fields in the record, and `outgoingData`\n\t\t// only contains updated fields, resulting in an error when doing a comparison\n\t\t// of two equal mutations. Fix this, or mitigate otherwise.\n\t\tif (!valuesEqual(incomingData, outgoingData, true)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mutationEventModelDefinition =\n\t\t\tthis.schema.namespaces[SYNC].models['MutationEvent'];\n\n\t\tconst userModelDefinition =\n\t\t\tthis.schema.namespaces['user'].models[head.model];\n\n\t\tconst recordId = getIdentifierValue(userModelDefinition, record);\n\n\t\tconst predicate = ModelPredicateCreator.createFromAST<MutationEvent>(\n\t\t\tmutationEventModelDefinition,\n\t\t\t{\n\t\t\t\tand: [\n\t\t\t\t\t{ modelId: { eq: recordId } },\n\t\t\t\t\t{ id: { ne: this.inProgressMutationEventId } },\n\t\t\t\t],\n\t\t\t}\n\t\t);\n\n\t\tconst outdatedMutations = await storage.query(\n\t\t\tthis.MutationEvent,\n\t\t\tpredicate\n\t\t);\n\n\t\tif (!outdatedMutations.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst reconciledMutations = outdatedMutations.map(m => {\n\t\t\tconst oldData = JSON.parse(m.data);\n\n\t\t\tconst newData = { ...oldData, _version, _lastChangedAt };\n\n\t\t\treturn this.MutationEvent.copyOf(m, draft => {\n\t\t\t\tdraft.data = JSON.stringify(newData);\n\t\t\t});\n\t\t});\n\n\t\tawait storage.delete(this.MutationEvent, predicate);\n\n\t\tawait Promise.all(\n\t\t\treconciledMutations.map(\n\t\t\t\tasync m => await storage.save(m, undefined, this.ownSymbol)\n\t\t\t)\n\t\t);\n\t}\n\n\tprivate mergeUserFields(\n\t\tprevious: MutationEvent,\n\t\tcurrent: MutationEvent\n\t): MutationEvent {\n\t\tconst { _version, _lastChangedAt, _deleted, ...previousData } = JSON.parse(\n\t\t\tprevious.data\n\t\t);\n\n\t\tconst {\n\t\t\t_version: __version,\n\t\t\t_lastChangedAt: __lastChangedAt,\n\t\t\t_deleted: __deleted,\n\t\t\t...currentData\n\t\t} = JSON.parse(current.data);\n\n\t\tconst data = JSON.stringify({\n\t\t\t_version,\n\t\t\t_lastChangedAt,\n\t\t\t_deleted,\n\t\t\t...previousData,\n\t\t\t...currentData,\n\t\t});\n\n\t\treturn this.modelInstanceCreator(this.MutationEvent, {\n\t\t\t...current,\n\t\t\tdata,\n\t\t});\n\t}\n\n\t/* \n\tif a model is using custom timestamp fields\n\tthe custom field names will be stored in the model attributes\n\n\te.g.\n\t\"attributes\": [\n    {\n\t\t\t\"type\": \"model\",\n\t\t\t\"properties\": {\n\t\t\t\t\"timestamps\": {\n\t\t\t\t\t\"createdAt\": \"createdOn\",\n\t\t\t\t\t\"updatedAt\": \"updatedOn\"\n\t\t\t\t}\n\t\t\t}\n    }\n\t]\n\t*/\n\tprivate removeTimestampFields(\n\t\tmodel: string,\n\t\trecord: PersistentModel\n\t): PersistentModel {\n\t\tconst CREATED_AT_DEFAULT_KEY = 'createdAt';\n\t\tconst UPDATED_AT_DEFAULT_KEY = 'updatedAt';\n\n\t\tlet createdTimestampKey = CREATED_AT_DEFAULT_KEY;\n\t\tlet updatedTimestampKey = UPDATED_AT_DEFAULT_KEY;\n\n\t\tconst modelAttributes = this.schema.namespaces[USER].models[\n\t\t\tmodel\n\t\t].attributes?.find(attr => attr.type === 'model');\n\t\tconst timestampFieldsMap = modelAttributes?.properties?.timestamps;\n\n\t\tif (timestampFieldsMap) {\n\t\t\tcreatedTimestampKey = timestampFieldsMap[CREATED_AT_DEFAULT_KEY];\n\t\t\tupdatedTimestampKey = timestampFieldsMap[UPDATED_AT_DEFAULT_KEY];\n\t\t}\n\n\t\tdelete (record as Record<string, any>)[createdTimestampKey];\n\t\tdelete (record as Record<string, any>)[updatedTimestampKey];\n\n\t\treturn record;\n\t}\n}\n\nexport { MutationEventOutbox };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}