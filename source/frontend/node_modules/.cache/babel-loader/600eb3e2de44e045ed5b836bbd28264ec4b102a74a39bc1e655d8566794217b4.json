{"ast":null,"code":"import { __asyncValues, __awaiter, __generator, __values } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ConsoleLogger as Logger } from '@aws-amplify/core';\nimport { ModelPredicateCreator } from '../../predicates';\nimport { isPredicateObj } from '../../types';\nimport { getStorename, getIndexKeys, extractPrimaryKeyValues, traverseModel, validatePredicate, isModelConstructor, extractPrimaryKeyFieldNames } from '../../util';\nimport { ModelRelationship } from '../relationship';\nvar logger = new Logger('DataStore');\nvar DB_NAME = 'amplify-datastore';\nvar StorageAdapterBase = /** @class */function () {\n  function StorageAdapterBase() {\n    this.dbName = DB_NAME;\n  }\n  /**\n   * Initializes local DB\n   *\n   * @param theSchema\n   * @param namespaceResolver\n   * @param modelInstanceCreator\n   * @param getModelConstructorByModelName\n   * @param sessionId\n   */\n  StorageAdapterBase.prototype.setUp = function (theSchema, namespaceResolver, modelInstanceCreator, getModelConstructorByModelName, sessionId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, error_1;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.preSetUpChecks()];\n          case 1:\n            _b.sent();\n            if (!!this.initPromise) return [3 /*break*/, 2];\n            this.initPromise = new Promise(function (res, rej) {\n              _this.resolve = res;\n              _this.reject = rej;\n            });\n            return [3 /*break*/, 4];\n          case 2:\n            return [4 /*yield*/, this.initPromise];\n          case 3:\n            _b.sent();\n            return [2 /*return*/];\n          case 4:\n            if (sessionId) {\n              this.dbName = DB_NAME + \"-\" + sessionId;\n            }\n            this.schema = theSchema;\n            this.namespaceResolver = namespaceResolver;\n            this.modelInstanceCreator = modelInstanceCreator;\n            this.getModelConstructorByModelName = getModelConstructorByModelName;\n            _b.label = 5;\n          case 5:\n            _b.trys.push([5, 8,, 9]);\n            if (!!this.db) return [3 /*break*/, 7];\n            _a = this;\n            return [4 /*yield*/, this.initDb()];\n          case 6:\n            _a.db = _b.sent();\n            this.resolve();\n            _b.label = 7;\n          case 7:\n            return [3 /*break*/, 9];\n          case 8:\n            error_1 = _b.sent();\n            this.reject(error_1);\n            return [3 /*break*/, 9];\n          case 9:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * @param modelConstructor\n   * @returns local DB table name\n   */\n  StorageAdapterBase.prototype.getStorenameForModel = function (modelConstructor) {\n    var namespace = this.namespaceResolver(modelConstructor);\n    var modelName = modelConstructor.name;\n    return getStorename(namespace, modelName);\n  };\n  /**\n   *\n   * @param model - instantiated model record\n   * @returns the record's primary key values\n   */\n  StorageAdapterBase.prototype.getIndexKeyValuesFromModel = function (model) {\n    var modelConstructor = Object.getPrototypeOf(model).constructor;\n    var namespaceName = this.namespaceResolver(modelConstructor);\n    var keys = getIndexKeys(this.schema.namespaces[namespaceName], modelConstructor.name);\n    return extractPrimaryKeyValues(model, keys);\n  };\n  /**\n   * Common metadata for `save` operation\n   * used by individual storage adapters\n   *\n   * @param model\n   */\n  StorageAdapterBase.prototype.saveMetadata = function (model) {\n    var _this = this;\n    var modelConstructor = Object.getPrototypeOf(model).constructor;\n    var storeName = this.getStorenameForModel(modelConstructor);\n    var namespaceName = this.namespaceResolver(modelConstructor);\n    var connectedModels = traverseModel(modelConstructor.name, model, this.schema.namespaces[namespaceName], this.modelInstanceCreator, this.getModelConstructorByModelName);\n    var set = new Set();\n    var connectionStoreNames = Object.values(connectedModels).map(function (_a) {\n      var modelName = _a.modelName,\n        item = _a.item,\n        instance = _a.instance;\n      var storeName = getStorename(namespaceName, modelName);\n      set.add(storeName);\n      var keys = getIndexKeys(_this.schema.namespaces[namespaceName], modelName);\n      return {\n        storeName: storeName,\n        item: item,\n        instance: instance,\n        keys: keys\n      };\n    });\n    var modelKeyValues = this.getIndexKeyValuesFromModel(model);\n    return {\n      storeName: storeName,\n      set: set,\n      connectionStoreNames: connectionStoreNames,\n      modelKeyValues: modelKeyValues\n    };\n  };\n  /**\n   * Enforces conditional save. Throws if condition is not met.\n   * used by individual storage adapters\n   *\n   * @param model\n   */\n  StorageAdapterBase.prototype.validateSaveCondition = function (condition, fromDB) {\n    if (!(condition && fromDB)) {\n      return;\n    }\n    var predicates = ModelPredicateCreator.getPredicates(condition);\n    var _a = predicates,\n      predicateObjs = _a.predicates,\n      type = _a.type;\n    var isValid = validatePredicate(fromDB, type, predicateObjs);\n    if (!isValid) {\n      var msg = 'Conditional update failed';\n      logger.error(msg, {\n        model: fromDB,\n        condition: predicateObjs\n      });\n      throw new Error(msg);\n    }\n  };\n  /**\n   * Instantiate models from POJO records returned from the database\n   *\n   * @param namespaceName - string model namespace\n   * @param srcModelName - string model name\n   * @param records - array of uninstantiated records\n   * @returns\n   */\n  StorageAdapterBase.prototype.load = function (namespaceName, srcModelName, records) {\n    return __awaiter(this, void 0, void 0, function () {\n      var namespace, relations, connectionStoreNames, modelConstructor;\n      var _this = this;\n      return __generator(this, function (_a) {\n        namespace = this.schema.namespaces[namespaceName];\n        relations = namespace.relationships[srcModelName].relationTypes;\n        connectionStoreNames = relations.map(function (_a) {\n          var modelName = _a.modelName;\n          return getStorename(namespaceName, modelName);\n        });\n        modelConstructor = this.getModelConstructorByModelName(namespaceName, srcModelName);\n        if (connectionStoreNames.length === 0) {\n          return [2 /*return*/, records.map(function (record) {\n            return _this.modelInstanceCreator(modelConstructor, record);\n          })];\n        }\n        return [2 /*return*/, records.map(function (record) {\n          return _this.modelInstanceCreator(modelConstructor, record);\n        })];\n      });\n    });\n  };\n  /**\n   * Extracts operands from a predicate group into an array of key values\n   * Used in the query method\n   *\n   * @param predicates - predicate group\n   * @param keyPath - string array of key names ['id', 'sortKey']\n   * @returns string[] of key values\n   *\n   * @example\n   * ```js\n   * { and:[{ id: { eq: 'abc' }}, { sortKey: { eq: 'def' }}] }\n   * ```\n   * Becomes\n   * ```\n   * ['abc', 'def']\n   * ```\n   */\n  StorageAdapterBase.prototype.keyValueFromPredicate = function (predicates, keyPath) {\n    var e_1, _a;\n    var predicateObjs = predicates.predicates;\n    if (predicateObjs.length !== keyPath.length) {\n      return;\n    }\n    var keyValues = [];\n    var _loop_1 = function (key) {\n      var predicateObj = predicateObjs.find(function (p) {\n        // it's a relevant predicate object only if it's an equality\n        // operation for a key field from the key:\n        return isPredicateObj(p) && p.field === key && p.operator === 'eq' && p.operand !== null && p.operand !== undefined;\n      });\n      predicateObj && keyValues.push(predicateObj.operand);\n    };\n    try {\n      for (var keyPath_1 = __values(keyPath), keyPath_1_1 = keyPath_1.next(); !keyPath_1_1.done; keyPath_1_1 = keyPath_1.next()) {\n        var key = keyPath_1_1.value;\n        _loop_1(key);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (keyPath_1_1 && !keyPath_1_1.done && (_a = keyPath_1.return)) _a.call(keyPath_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return keyValues.length === keyPath.length ? keyValues : undefined;\n  };\n  /**\n   * Common metadata for `query` operation\n   * used by individual storage adapters\n   *\n   * @param modelConstructor\n   * @param predicate\n   * @param pagination\n   */\n  StorageAdapterBase.prototype.queryMetadata = function (modelConstructor, predicate, pagination) {\n    var storeName = this.getStorenameForModel(modelConstructor);\n    var namespaceName = this.namespaceResolver(modelConstructor);\n    var predicates = predicate && ModelPredicateCreator.getPredicates(predicate);\n    var keyPath = getIndexKeys(this.schema.namespaces[namespaceName], modelConstructor.name);\n    var queryByKey = predicates && this.keyValueFromPredicate(predicates, keyPath);\n    var hasSort = pagination && pagination.sort;\n    var hasPagination = pagination && pagination.limit;\n    return {\n      storeName: storeName,\n      namespaceName: namespaceName,\n      queryByKey: queryByKey,\n      predicates: predicates,\n      hasSort: hasSort,\n      hasPagination: hasPagination\n    };\n  };\n  /**\n   * Delete record\n   * Cascades to related records (for Has One and Has Many relationships)\n   *\n   * @param modelOrModelConstructor\n   * @param condition\n   * @returns\n   */\n  StorageAdapterBase.prototype.delete = function (modelOrModelConstructor, condition) {\n    return __awaiter(this, void 0, void 0, function () {\n      var deleteQueue, modelConstructor, namespace, models, deletedModels, deletedModels, model, modelConstructor, namespaceName, storeName, keyValues, fromDB, msg, predicates, _a, predicateObjs, type, isValid, msg, deletedModels;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.preOpCheck()];\n          case 1:\n            _b.sent();\n            deleteQueue = [];\n            if (!isModelConstructor(modelOrModelConstructor)) return [3 /*break*/, 9];\n            modelConstructor = modelOrModelConstructor;\n            namespace = this.namespaceResolver(modelConstructor);\n            return [4 /*yield*/, this.query(modelConstructor, condition)];\n          case 2:\n            models = _b.sent();\n            if (!(condition !== undefined)) return [3 /*break*/, 5];\n            return [4 /*yield*/, this.deleteTraverse(models, modelConstructor, namespace, deleteQueue)];\n          case 3:\n            _b.sent();\n            return [4 /*yield*/, this.deleteItem(deleteQueue)];\n          case 4:\n            _b.sent();\n            deletedModels = deleteQueue.reduce(function (acc, _a) {\n              var items = _a.items;\n              return acc.concat(items);\n            }, []);\n            return [2 /*return*/, [models, deletedModels]];\n          case 5:\n            return [4 /*yield*/, this.deleteTraverse(models, modelConstructor, namespace, deleteQueue)];\n          case 6:\n            _b.sent();\n            return [4 /*yield*/, this.deleteItem(deleteQueue)];\n          case 7:\n            _b.sent();\n            deletedModels = deleteQueue.reduce(function (acc, _a) {\n              var items = _a.items;\n              return acc.concat(items);\n            }, []);\n            return [2 /*return*/, [models, deletedModels]];\n          case 8:\n            return [3 /*break*/, 16];\n          case 9:\n            model = modelOrModelConstructor;\n            modelConstructor = Object.getPrototypeOf(model).constructor;\n            namespaceName = this.namespaceResolver(modelConstructor);\n            storeName = this.getStorenameForModel(modelConstructor);\n            if (!condition) return [3 /*break*/, 12];\n            keyValues = this.getIndexKeyValuesFromModel(model);\n            return [4 /*yield*/, this._get(storeName, keyValues)];\n          case 10:\n            fromDB = _b.sent();\n            if (fromDB === undefined) {\n              msg = 'Model instance not found in storage';\n              logger.warn(msg, {\n                model: model\n              });\n              return [2 /*return*/, [[model], []]];\n            }\n            predicates = ModelPredicateCreator.getPredicates(condition);\n            _a = predicates, predicateObjs = _a.predicates, type = _a.type;\n            isValid = validatePredicate(fromDB, type, predicateObjs);\n            if (!isValid) {\n              msg = 'Conditional update failed';\n              logger.error(msg, {\n                model: fromDB,\n                condition: predicateObjs\n              });\n              throw new Error(msg);\n            }\n            return [4 /*yield*/, this.deleteTraverse([model], modelConstructor, namespaceName, deleteQueue)];\n          case 11:\n            _b.sent();\n            return [3 /*break*/, 14];\n          case 12:\n            return [4 /*yield*/, this.deleteTraverse([model], modelConstructor, namespaceName, deleteQueue)];\n          case 13:\n            _b.sent();\n            _b.label = 14;\n          case 14:\n            return [4 /*yield*/, this.deleteItem(deleteQueue)];\n          case 15:\n            _b.sent();\n            deletedModels = deleteQueue.reduce(function (acc, _a) {\n              var items = _a.items;\n              return acc.concat(items);\n            }, []);\n            return [2 /*return*/, [[model], deletedModels]];\n          case 16:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Recursively traverse relationship graph and add\n   * all Has One and Has Many relations to `deleteQueue` param\n   *\n   * Actual deletion of records added to `deleteQueue` occurs in the `delete` method\n   *\n   * @param models\n   * @param modelConstructor\n   * @param namespace\n   * @param deleteQueue\n   */\n  StorageAdapterBase.prototype.deleteTraverse = function (models, modelConstructor, namespace, deleteQueue) {\n    var models_1, models_1_1;\n    var e_2, _a, e_3, _b;\n    return __awaiter(this, void 0, void 0, function () {\n      var cascadingRelationTypes, model, modelDefinition, modelMeta, relationships, relationships_1, relationships_1_1, r, queryObject, relatedRecords, e_3_1, e_2_1;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            cascadingRelationTypes = ['HAS_ONE', 'HAS_MANY'];\n            _c.label = 1;\n          case 1:\n            _c.trys.push([1, 19, 20, 25]);\n            models_1 = __asyncValues(models);\n            _c.label = 2;\n          case 2:\n            return [4 /*yield*/, models_1.next()];\n          case 3:\n            if (!(models_1_1 = _c.sent(), !models_1_1.done)) return [3 /*break*/, 18];\n            model = models_1_1.value;\n            modelDefinition = this.schema.namespaces[namespace].models[modelConstructor.name];\n            modelMeta = {\n              builder: modelConstructor,\n              schema: modelDefinition,\n              pkField: extractPrimaryKeyFieldNames(modelDefinition)\n            };\n            relationships = ModelRelationship.allFrom(modelMeta).filter(function (r) {\n              return cascadingRelationTypes.includes(r.type);\n            });\n            _c.label = 4;\n          case 4:\n            _c.trys.push([4, 11, 12, 17]);\n            relationships_1 = __asyncValues(relationships);\n            _c.label = 5;\n          case 5:\n            return [4 /*yield*/, relationships_1.next()];\n          case 6:\n            if (!(relationships_1_1 = _c.sent(), !relationships_1_1.done)) return [3 /*break*/, 10];\n            r = relationships_1_1.value;\n            queryObject = r.createRemoteQueryObject(model);\n            if (!(queryObject !== null)) return [3 /*break*/, 9];\n            return [4 /*yield*/, this.query(r.remoteModelConstructor, ModelPredicateCreator.createFromFlatEqualities(r.remoteDefinition, queryObject))];\n          case 7:\n            relatedRecords = _c.sent();\n            return [4 /*yield*/, this.deleteTraverse(relatedRecords, r.remoteModelConstructor, namespace, deleteQueue)];\n          case 8:\n            _c.sent();\n            _c.label = 9;\n          case 9:\n            return [3 /*break*/, 5];\n          case 10:\n            return [3 /*break*/, 17];\n          case 11:\n            e_3_1 = _c.sent();\n            e_3 = {\n              error: e_3_1\n            };\n            return [3 /*break*/, 17];\n          case 12:\n            _c.trys.push([12,, 15, 16]);\n            if (!(relationships_1_1 && !relationships_1_1.done && (_b = relationships_1.return))) return [3 /*break*/, 14];\n            return [4 /*yield*/, _b.call(relationships_1)];\n          case 13:\n            _c.sent();\n            _c.label = 14;\n          case 14:\n            return [3 /*break*/, 16];\n          case 15:\n            if (e_3) throw e_3.error;\n            return [7 /*endfinally*/];\n          case 16:\n            return [7 /*endfinally*/];\n          case 17:\n            return [3 /*break*/, 2];\n          case 18:\n            return [3 /*break*/, 25];\n          case 19:\n            e_2_1 = _c.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3 /*break*/, 25];\n          case 20:\n            _c.trys.push([20,, 23, 24]);\n            if (!(models_1_1 && !models_1_1.done && (_a = models_1.return))) return [3 /*break*/, 22];\n            return [4 /*yield*/, _a.call(models_1)];\n          case 21:\n            _c.sent();\n            _c.label = 22;\n          case 22:\n            return [3 /*break*/, 24];\n          case 23:\n            if (e_2) throw e_2.error;\n            return [7 /*endfinally*/];\n          case 24:\n            return [7 /*endfinally*/];\n          case 25:\n            deleteQueue.push({\n              storeName: getStorename(namespace, modelConstructor.name),\n              items: models\n            });\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  return StorageAdapterBase;\n}();\nexport { StorageAdapterBase };","map":{"version":3,"mappings":"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","names":["ConsoleLogger","Logger","ModelPredicateCreator","isPredicateObj","getStorename","getIndexKeys","extractPrimaryKeyValues","traverseModel","validatePredicate","isModelConstructor","extractPrimaryKeyFieldNames","ModelRelationship","logger","DB_NAME","StorageAdapterBase","theSchema","namespaceResolver","modelInstanceCreator","getModelConstructorByModelName","sessionId","preSetUpChecks","_b","initPromise","Promise","res","rej","_this","resolve","reject","dbName","schema","db","_a","initDb","error_1","modelConstructor","namespace","modelName","model","Object","getPrototypeOf","constructor","namespaceName","keys","namespaces","name","storeName","getStorenameForModel","connectedModels","set","Set","connectionStoreNames","values","map","item","instance","add","modelKeyValues","getIndexKeyValuesFromModel","condition","fromDB","predicates","getPredicates","predicateObjs","type","isValid","msg","error","Error","srcModelName","records","relations","relationships","relationTypes","length","record","keyPath","keyValues","key","predicateObj","find","p","field","operator","operand","undefined","push","predicate","pagination","queryByKey","keyValueFromPredicate","hasSort","sort","hasPagination","limit","modelOrModelConstructor","preOpCheck","deleteQueue","query","models","deleteTraverse","deleteItem","deletedModels","reduce","acc","items","concat","_get","warn","cascadingRelationTypes","models_1","modelDefinition","modelMeta","builder","pkField","allFrom","filter","includes","r","relationships_1","queryObject","createRemoteQueryObject","remoteModelConstructor","createFromFlatEqualities","remoteDefinition","relatedRecords","_c"],"sources":["/Workshop/product-metadata/guidance-for-generating-product-descriptions-with-bedrock/source/frontend/node_modules/@aws-amplify/datastore/src/storage/adapter/StorageAdapterBase.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ConsoleLogger as Logger } from '@aws-amplify/core';\nimport { Adapter } from './index';\nimport { ModelInstanceCreator } from '../../datastore/datastore';\nimport { ModelPredicateCreator } from '../../predicates';\nimport {\n\tInternalSchema,\n\tisPredicateObj,\n\tModelInstanceMetadata,\n\tModelPredicate,\n\tNamespaceResolver,\n\tOpType,\n\tPaginationInput,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tPredicateObject,\n\tPredicatesGroup,\n\tQueryOne,\n} from '../../types';\nimport {\n\tNAMESPACES,\n\tgetStorename,\n\tgetIndexKeys,\n\textractPrimaryKeyValues,\n\ttraverseModel,\n\tvalidatePredicate,\n\tisModelConstructor,\n\textractPrimaryKeyFieldNames,\n} from '../../util';\nimport type { IDBPDatabase, IDBPObjectStore } from 'idb';\nimport type AsyncStorageDatabase from './AsyncStorageDatabase';\nimport { ModelRelationship } from '../relationship';\n\nconst logger = new Logger('DataStore');\nconst DB_NAME = 'amplify-datastore';\n\nexport abstract class StorageAdapterBase implements Adapter {\n\t// Non-null assertions (bang operators) added to most properties to make TS happy.\n\t// For now, we can be reasonably sure they're available when they're needed, because\n\t// the adapter is not used directly outside the library boundary.\n\tprotected schema!: InternalSchema;\n\tprotected namespaceResolver!: NamespaceResolver;\n\tprotected modelInstanceCreator!: ModelInstanceCreator;\n\tprotected getModelConstructorByModelName!: (\n\t\tnamsespaceName: NAMESPACES,\n\t\tmodelName: string\n\t) => PersistentModelConstructor<any>;\n\tprotected initPromise!: Promise<void>;\n\tprotected resolve!: (value?: any) => void;\n\tprotected reject!: (value?: any) => void;\n\tprotected dbName: string = DB_NAME;\n\tprotected abstract db: IDBPDatabase | AsyncStorageDatabase;\n\n\tprotected abstract preSetUpChecks(): Promise<void>;\n\tprotected abstract preOpCheck(): Promise<void>;\n\tprotected abstract initDb(): Promise<IDBPDatabase | AsyncStorageDatabase>;\n\n\t/**\n\t * Initializes local DB\n\t *\n\t * @param theSchema\n\t * @param namespaceResolver\n\t * @param modelInstanceCreator\n\t * @param getModelConstructorByModelName\n\t * @param sessionId\n\t */\n\tpublic async setUp(\n\t\ttheSchema: InternalSchema,\n\t\tnamespaceResolver: NamespaceResolver,\n\t\tmodelInstanceCreator: ModelInstanceCreator,\n\t\tgetModelConstructorByModelName: (\n\t\t\tnamsespaceName: NAMESPACES,\n\t\t\tmodelName: string\n\t\t) => PersistentModelConstructor<any>,\n\t\tsessionId?: string\n\t): Promise<void> {\n\t\tawait this.preSetUpChecks();\n\n\t\tif (!this.initPromise) {\n\t\t\tthis.initPromise = new Promise((res, rej) => {\n\t\t\t\tthis.resolve = res;\n\t\t\t\tthis.reject = rej;\n\t\t\t});\n\t\t} else {\n\t\t\tawait this.initPromise;\n\t\t\treturn;\n\t\t}\n\t\tif (sessionId) {\n\t\t\tthis.dbName = `${DB_NAME}-${sessionId}`;\n\t\t}\n\t\tthis.schema = theSchema;\n\t\tthis.namespaceResolver = namespaceResolver;\n\t\tthis.modelInstanceCreator = modelInstanceCreator;\n\t\tthis.getModelConstructorByModelName = getModelConstructorByModelName;\n\n\t\ttry {\n\t\t\tif (!this.db) {\n\t\t\t\tthis.db = await this.initDb();\n\t\t\t\tthis.resolve();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.reject(error);\n\t\t}\n\t}\n\n\t/*\n\t * Abstract Methods for Adapter interface\n\t * Not enough implementation similarities between the adapters\n\t * to consolidate in the base class\n\t */\n\tpublic abstract clear(): Promise<void>;\n\n\tpublic abstract save<T extends PersistentModel>(\n\t\tmodel: T,\n\t\tcondition?: ModelPredicate<T>\n\t);\n\n\tpublic abstract query<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tpredicate?: ModelPredicate<T>,\n\t\tpagination?: PaginationInput<T>\n\t): Promise<T[]>;\n\n\tpublic abstract queryOne<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tfirstOrLast: QueryOne\n\t): Promise<T | undefined>;\n\n\tpublic abstract batchSave<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<any>,\n\t\titems: ModelInstanceMetadata[]\n\t): Promise<[T, OpType][]>;\n\n\t/**\n\t * @param modelConstructor\n\t * @returns local DB table name\n\t */\n\tprotected getStorenameForModel(\n\t\tmodelConstructor: PersistentModelConstructor<any>\n\t): string {\n\t\tconst namespace = this.namespaceResolver(modelConstructor);\n\t\tconst { name: modelName } = modelConstructor;\n\n\t\treturn getStorename(namespace, modelName);\n\t}\n\n\t/**\n\t *\n\t * @param model - instantiated model record\n\t * @returns the record's primary key values\n\t */\n\tprotected getIndexKeyValuesFromModel<T extends PersistentModel>(\n\t\tmodel: T\n\t): string[] {\n\t\tconst modelConstructor = Object.getPrototypeOf(model)\n\t\t\t.constructor as PersistentModelConstructor<T>;\n\t\tconst namespaceName = this.namespaceResolver(modelConstructor);\n\n\t\tconst keys = getIndexKeys(\n\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\tmodelConstructor.name\n\t\t);\n\n\t\treturn extractPrimaryKeyValues(model, keys);\n\t}\n\n\t/**\n\t * Common metadata for `save` operation\n\t * used by individual storage adapters\n\t *\n\t * @param model\n\t */\n\tprotected saveMetadata<T extends PersistentModel>(\n\t\tmodel: T\n\t): {\n\t\tstoreName: string;\n\t\tset: Set<string>;\n\t\tconnectionStoreNames;\n\t\tmodelKeyValues: string[];\n\t} {\n\t\tconst modelConstructor = Object.getPrototypeOf(model)\n\t\t\t.constructor as PersistentModelConstructor<T>;\n\t\tconst storeName = this.getStorenameForModel(modelConstructor);\n\t\tconst namespaceName = this.namespaceResolver(modelConstructor);\n\n\t\tconst connectedModels = traverseModel(\n\t\t\tmodelConstructor.name,\n\t\t\tmodel,\n\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\tthis.modelInstanceCreator,\n\t\t\tthis.getModelConstructorByModelName!\n\t\t);\n\n\t\tconst set = new Set<string>();\n\t\tconst connectionStoreNames = Object.values(connectedModels).map(\n\t\t\t({ modelName, item, instance }) => {\n\t\t\t\tconst storeName = getStorename(namespaceName, modelName);\n\t\t\t\tset.add(storeName);\n\t\t\t\tconst keys = getIndexKeys(\n\t\t\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\t\t\tmodelName\n\t\t\t\t);\n\t\t\t\treturn { storeName, item, instance, keys };\n\t\t\t}\n\t\t);\n\n\t\tconst modelKeyValues = this.getIndexKeyValuesFromModel(model);\n\n\t\treturn { storeName, set, connectionStoreNames, modelKeyValues };\n\t}\n\n\t/**\n\t * Enforces conditional save. Throws if condition is not met.\n\t * used by individual storage adapters\n\t *\n\t * @param model\n\t */\n\tprotected validateSaveCondition<T extends PersistentModel>(\n\t\tcondition?: ModelPredicate<T>,\n\t\tfromDB?: unknown\n\t): void {\n\t\tif (!(condition && fromDB)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst predicates = ModelPredicateCreator.getPredicates(condition);\n\t\tconst { predicates: predicateObjs, type } = predicates!;\n\n\t\tconst isValid = validatePredicate(fromDB, type, predicateObjs);\n\n\t\tif (!isValid) {\n\t\t\tconst msg = 'Conditional update failed';\n\t\t\tlogger.error(msg, { model: fromDB, condition: predicateObjs });\n\n\t\t\tthrow new Error(msg);\n\t\t}\n\t}\n\n\tprotected abstract _get<T>(\n\t\tstoreOrStoreName: IDBPObjectStore | string,\n\t\tkeyArr: string[]\n\t): Promise<T>;\n\n\t/**\n\t * Instantiate models from POJO records returned from the database\n\t *\n\t * @param namespaceName - string model namespace\n\t * @param srcModelName - string model name\n\t * @param records - array of uninstantiated records\n\t * @returns\n\t */\n\tprotected async load<T>(\n\t\tnamespaceName: NAMESPACES,\n\t\tsrcModelName: string,\n\t\trecords: T[]\n\t): Promise<T[]> {\n\t\tconst namespace = this.schema.namespaces[namespaceName];\n\t\tconst relations = namespace.relationships![srcModelName].relationTypes;\n\t\tconst connectionStoreNames = relations.map(({ modelName }) => {\n\t\t\treturn getStorename(namespaceName, modelName);\n\t\t});\n\t\tconst modelConstructor = this.getModelConstructorByModelName!(\n\t\t\tnamespaceName,\n\t\t\tsrcModelName\n\t\t);\n\n\t\tif (connectionStoreNames.length === 0) {\n\t\t\treturn records.map(record =>\n\t\t\t\tthis.modelInstanceCreator(modelConstructor, record)\n\t\t\t);\n\t\t}\n\n\t\treturn records.map(record =>\n\t\t\tthis.modelInstanceCreator(modelConstructor, record)\n\t\t);\n\t}\n\n\t/**\n\t * Extracts operands from a predicate group into an array of key values\n\t * Used in the query method\n\t *\n\t * @param predicates - predicate group\n\t * @param keyPath - string array of key names ['id', 'sortKey']\n\t * @returns string[] of key values\n\t *\n\t * @example\n\t * ```js\n\t * { and:[{ id: { eq: 'abc' }}, { sortKey: { eq: 'def' }}] }\n\t * ```\n\t * Becomes\n\t * ```\n\t * ['abc', 'def']\n\t * ```\n\t */\n\tprivate keyValueFromPredicate<T extends PersistentModel>(\n\t\tpredicates: PredicatesGroup<T>,\n\t\tkeyPath: string[]\n\t): string[] | undefined {\n\t\tconst { predicates: predicateObjs } = predicates;\n\n\t\tif (predicateObjs.length !== keyPath.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst keyValues = [] as any[];\n\n\t\tfor (const key of keyPath) {\n\t\t\tconst predicateObj = predicateObjs.find(\n\t\t\t\tp =>\n\t\t\t\t\t// it's a relevant predicate object only if it's an equality\n\t\t\t\t\t// operation for a key field from the key:\n\t\t\t\t\tisPredicateObj(p) &&\n\t\t\t\t\tp.field === key &&\n\t\t\t\t\tp.operator === 'eq' &&\n\t\t\t\t\tp.operand !== null &&\n\t\t\t\t\tp.operand !== undefined\n\t\t\t) as PredicateObject<T>;\n\n\t\t\tpredicateObj && keyValues.push(predicateObj.operand);\n\t\t}\n\n\t\treturn keyValues.length === keyPath.length ? keyValues : undefined;\n\t}\n\n\t/**\n\t * Common metadata for `query` operation\n\t * used by individual storage adapters\n\t *\n\t * @param modelConstructor\n\t * @param predicate\n\t * @param pagination\n\t */\n\tprotected queryMetadata<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tpredicate?: ModelPredicate<T>,\n\t\tpagination?: PaginationInput<T>\n\t) {\n\t\tconst storeName = this.getStorenameForModel(modelConstructor);\n\t\tconst namespaceName = this.namespaceResolver(\n\t\t\tmodelConstructor\n\t\t) as NAMESPACES;\n\n\t\tconst predicates =\n\t\t\tpredicate && ModelPredicateCreator.getPredicates(predicate);\n\t\tconst keyPath = getIndexKeys(\n\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\tmodelConstructor.name\n\t\t);\n\t\tconst queryByKey =\n\t\t\tpredicates && this.keyValueFromPredicate(predicates, keyPath);\n\n\t\tconst hasSort = pagination && pagination.sort;\n\t\tconst hasPagination = pagination && pagination.limit;\n\n\t\treturn {\n\t\t\tstoreName,\n\t\t\tnamespaceName,\n\t\t\tqueryByKey,\n\t\t\tpredicates,\n\t\t\thasSort,\n\t\t\thasPagination,\n\t\t};\n\t}\n\n\t/**\n\t * Delete record\n\t * Cascades to related records (for Has One and Has Many relationships)\n\t *\n\t * @param modelOrModelConstructor\n\t * @param condition\n\t * @returns\n\t */\n\tpublic async delete<T extends PersistentModel>(\n\t\tmodelOrModelConstructor: T | PersistentModelConstructor<T>,\n\t\tcondition?: ModelPredicate<T>\n\t): Promise<[T[], T[]]> {\n\t\tawait this.preOpCheck();\n\n\t\tconst deleteQueue: { storeName: string; items: T[] }[] = [];\n\n\t\tif (isModelConstructor(modelOrModelConstructor)) {\n\t\t\tconst modelConstructor =\n\t\t\t\tmodelOrModelConstructor as PersistentModelConstructor<T>;\n\t\t\tconst namespace = this.namespaceResolver(modelConstructor) as NAMESPACES;\n\t\t\tconst models = await this.query(modelConstructor, condition);\n\n\t\t\tif (condition !== undefined) {\n\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\tmodels,\n\t\t\t\t\tmodelConstructor,\n\t\t\t\t\tnamespace,\n\t\t\t\t\tdeleteQueue\n\t\t\t\t);\n\n\t\t\t\tawait this.deleteItem(deleteQueue);\n\n\t\t\t\tconst deletedModels = deleteQueue.reduce(\n\t\t\t\t\t(acc, { items }) => acc.concat(items),\n\t\t\t\t\t<T[]>[]\n\t\t\t\t);\n\n\t\t\t\treturn [models, deletedModels];\n\t\t\t} else {\n\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\tmodels,\n\t\t\t\t\tmodelConstructor,\n\t\t\t\t\tnamespace,\n\t\t\t\t\tdeleteQueue\n\t\t\t\t);\n\n\t\t\t\tawait this.deleteItem(deleteQueue);\n\n\t\t\t\tconst deletedModels = deleteQueue.reduce(\n\t\t\t\t\t(acc, { items }) => acc.concat(items),\n\t\t\t\t\t<T[]>[]\n\t\t\t\t);\n\n\t\t\t\treturn [models, deletedModels];\n\t\t\t}\n\t\t} else {\n\t\t\tconst model = modelOrModelConstructor as T;\n\n\t\t\tconst modelConstructor = Object.getPrototypeOf(model)\n\t\t\t\t.constructor as PersistentModelConstructor<T>;\n\n\t\t\tconst namespaceName = this.namespaceResolver(\n\t\t\t\tmodelConstructor\n\t\t\t) as NAMESPACES;\n\n\t\t\tconst storeName = this.getStorenameForModel(modelConstructor);\n\n\t\t\tif (condition) {\n\t\t\t\tconst keyValues = this.getIndexKeyValuesFromModel(model);\n\t\t\t\tconst fromDB = await this._get(storeName, keyValues);\n\n\t\t\t\tif (fromDB === undefined) {\n\t\t\t\t\tconst msg = 'Model instance not found in storage';\n\t\t\t\t\tlogger.warn(msg, { model });\n\n\t\t\t\t\treturn [[model], []];\n\t\t\t\t}\n\n\t\t\t\tconst predicates = ModelPredicateCreator.getPredicates(condition);\n\t\t\t\tconst { predicates: predicateObjs, type } =\n\t\t\t\t\tpredicates as PredicatesGroup<T>;\n\n\t\t\t\tconst isValid = validatePredicate(fromDB as T, type, predicateObjs);\n\t\t\t\tif (!isValid) {\n\t\t\t\t\tconst msg = 'Conditional update failed';\n\t\t\t\t\tlogger.error(msg, { model: fromDB, condition: predicateObjs });\n\n\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t}\n\n\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\t[model],\n\t\t\t\t\tmodelConstructor,\n\t\t\t\t\tnamespaceName,\n\t\t\t\t\tdeleteQueue\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\t[model],\n\t\t\t\t\tmodelConstructor,\n\t\t\t\t\tnamespaceName,\n\t\t\t\t\tdeleteQueue\n\t\t\t\t);\n\t\t\t}\n\t\t\tawait this.deleteItem(deleteQueue);\n\n\t\t\tconst deletedModels = deleteQueue.reduce(\n\t\t\t\t(acc, { items }) => acc.concat(items),\n\t\t\t\t<T[]>[]\n\t\t\t);\n\n\t\t\treturn [[model], deletedModels];\n\t\t}\n\t}\n\n\tprotected abstract deleteItem<T extends PersistentModel>(\n\t\tdeleteQueue?: {\n\t\t\tstoreName: string;\n\t\t\titems: T[] | IDBValidKey[];\n\t\t}[]\n\t);\n\n\t/**\n\t * Recursively traverse relationship graph and add\n\t * all Has One and Has Many relations to `deleteQueue` param\n\t *\n\t * Actual deletion of records added to `deleteQueue` occurs in the `delete` method\n\t *\n\t * @param models\n\t * @param modelConstructor\n\t * @param namespace\n\t * @param deleteQueue\n\t */\n\tprivate async deleteTraverse<T extends PersistentModel>(\n\t\tmodels: T[],\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tnamespace: NAMESPACES,\n\t\tdeleteQueue: { storeName: string; items: T[] }[]\n\t): Promise<void> {\n\t\tconst cascadingRelationTypes = ['HAS_ONE', 'HAS_MANY'];\n\n\t\tfor await (const model of models) {\n\t\t\tconst modelDefinition =\n\t\t\t\tthis.schema.namespaces[namespace].models[modelConstructor.name];\n\n\t\t\tconst modelMeta = {\n\t\t\t\tbuilder: modelConstructor,\n\t\t\t\tschema: modelDefinition,\n\t\t\t\tpkField: extractPrimaryKeyFieldNames(modelDefinition),\n\t\t\t};\n\n\t\t\tconst relationships = ModelRelationship.allFrom(modelMeta).filter(r =>\n\t\t\t\tcascadingRelationTypes.includes(r.type)\n\t\t\t);\n\n\t\t\tfor await (const r of relationships) {\n\t\t\t\tconst queryObject = r.createRemoteQueryObject(model);\n\t\t\t\tif (queryObject !== null) {\n\t\t\t\t\tconst relatedRecords = await this.query(\n\t\t\t\t\t\tr.remoteModelConstructor,\n\t\t\t\t\t\tModelPredicateCreator.createFromFlatEqualities(\n\t\t\t\t\t\t\tr.remoteDefinition!,\n\t\t\t\t\t\t\tqueryObject\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\t\trelatedRecords,\n\t\t\t\t\t\tr.remoteModelConstructor,\n\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\tdeleteQueue\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdeleteQueue.push({\n\t\t\tstoreName: getStorename(namespace, modelConstructor.name),\n\t\t\titems: models,\n\t\t});\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}