{"ast":null,"code":"import { __asyncValues, __awaiter, __extends, __generator, __values } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport AsyncStorageDatabase from './AsyncStorageDatabase';\nimport { OpType, QueryOne } from '../../types';\nimport { DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR, traverseModel, validatePredicate, inMemoryPagination, keysEqual, getStorename, getIndexKeys } from '../../util';\nimport { StorageAdapterBase } from './StorageAdapterBase';\nvar AsyncStorageAdapter = /** @class */function (_super) {\n  __extends(AsyncStorageAdapter, _super);\n  function AsyncStorageAdapter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  // no-ops for this adapter\n  AsyncStorageAdapter.prototype.preSetUpChecks = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/];\n      });\n    });\n  };\n\n  AsyncStorageAdapter.prototype.preOpCheck = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/];\n      });\n    });\n  };\n  /**\n   * Open AsyncStorage database\n   * Create new DB if one doesn't exist\n   *\n   * Called by `StorageAdapterBase.setUp()`\n   *\n   * @returns AsyncStorageDatabase instance\n   */\n  AsyncStorageAdapter.prototype.initDb = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var db;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            db = new AsyncStorageDatabase();\n            return [4 /*yield*/, db.init()];\n          case 1:\n            _a.sent();\n            return [2 /*return*/, db];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.db.clear()];\n          case 1:\n            _a.sent();\n            this.db = undefined;\n            this.initPromise = undefined;\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  AsyncStorageAdapter.prototype.batchSave = function (modelConstructor, items) {\n    return __awaiter(this, void 0, void 0, function () {\n      var modelName, namespaceName, storeName, keys, batch, _loop_1, this_1, items_1, items_1_1, item;\n      var e_1, _a;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (items.length === 0) {\n              return [2 /*return*/, []];\n            }\n            modelName = modelConstructor.name;\n            namespaceName = this.namespaceResolver(modelConstructor);\n            storeName = getStorename(namespaceName, modelName);\n            keys = getIndexKeys(this.schema.namespaces[namespaceName], modelName);\n            batch = [];\n            _loop_1 = function (item) {\n              var model = this_1.modelInstanceCreator(modelConstructor, item);\n              var connectedModels = traverseModel(modelName, model, this_1.schema.namespaces[namespaceName], this_1.modelInstanceCreator, this_1.getModelConstructorByModelName);\n              var keyValuesPath = this_1.getIndexKeyValuesPath(model);\n              var instance = connectedModels.find(function (_a) {\n                var instance = _a.instance;\n                var instanceKeyValuesPath = _this.getIndexKeyValuesPath(instance);\n                return keysEqual([instanceKeyValuesPath], [keyValuesPath]);\n              }).instance;\n              batch.push(instance);\n            };\n            this_1 = this;\n            try {\n              for (items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {\n                item = items_1_1.value;\n                _loop_1(item);\n              }\n            } catch (e_1_1) {\n              e_1 = {\n                error: e_1_1\n              };\n            } finally {\n              try {\n                if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);\n              } finally {\n                if (e_1) throw e_1.error;\n              }\n            }\n            return [4 /*yield*/, this.db.batchSave(storeName, batch, keys)];\n          case 1:\n            return [2 /*return*/, _b.sent()];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype._get = function (storeName, keyArr) {\n    return __awaiter(this, void 0, void 0, function () {\n      var itemKeyValuesPath;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            itemKeyValuesPath = keyArr.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n            return [4 /*yield*/, this.db.get(itemKeyValuesPath, storeName)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.save = function (model, condition) {\n    var e_2, _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var _b, storeName, connectionStoreNames, modelKeyValues, fromDB, result, connectionStoreNames_1, connectionStoreNames_1_1, resItem, storeName_1, item, instance, keys, itemKeyValues, fromDB_1, opType, e_2_1;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _b = this.saveMetadata(model), storeName = _b.storeName, connectionStoreNames = _b.connectionStoreNames, modelKeyValues = _b.modelKeyValues;\n            return [4 /*yield*/, this._get(storeName, modelKeyValues)];\n          case 1:\n            fromDB = _c.sent();\n            this.validateSaveCondition(condition, fromDB);\n            result = [];\n            _c.label = 2;\n          case 2:\n            _c.trys.push([2, 9, 10, 15]);\n            connectionStoreNames_1 = __asyncValues(connectionStoreNames);\n            _c.label = 3;\n          case 3:\n            return [4 /*yield*/, connectionStoreNames_1.next()];\n          case 4:\n            if (!(connectionStoreNames_1_1 = _c.sent(), !connectionStoreNames_1_1.done)) return [3 /*break*/, 8];\n            resItem = connectionStoreNames_1_1.value;\n            storeName_1 = resItem.storeName, item = resItem.item, instance = resItem.instance, keys = resItem.keys;\n            itemKeyValues = keys.map(function (key) {\n              return item[key];\n            });\n            return [4 /*yield*/, this._get(storeName_1, itemKeyValues)];\n          case 5:\n            fromDB_1 = _c.sent();\n            opType = fromDB_1 ? OpType.UPDATE : OpType.INSERT;\n            if (!(keysEqual(itemKeyValues, modelKeyValues) || opType === OpType.INSERT)) return [3 /*break*/, 7];\n            return [4 /*yield*/, this.db.save(item, storeName_1, keys, itemKeyValues.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR))];\n          case 6:\n            _c.sent();\n            result.push([instance, opType]);\n            _c.label = 7;\n          case 7:\n            return [3 /*break*/, 3];\n          case 8:\n            return [3 /*break*/, 15];\n          case 9:\n            e_2_1 = _c.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3 /*break*/, 15];\n          case 10:\n            _c.trys.push([10,, 13, 14]);\n            if (!(connectionStoreNames_1_1 && !connectionStoreNames_1_1.done && (_a = connectionStoreNames_1.return))) return [3 /*break*/, 12];\n            return [4 /*yield*/, _a.call(connectionStoreNames_1)];\n          case 11:\n            _c.sent();\n            _c.label = 12;\n          case 12:\n            return [3 /*break*/, 14];\n          case 13:\n            if (e_2) throw e_2.error;\n            return [7 /*endfinally*/];\n          case 14:\n            return [7 /*endfinally*/];\n          case 15:\n            return [2 /*return*/, result];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.query = function (modelConstructor, predicate, pagination) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, storeName, namespaceName, queryByKey, predicates, hasSort, hasPagination, records;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.queryMetadata(modelConstructor, predicate, pagination), storeName = _a.storeName, namespaceName = _a.namespaceName, queryByKey = _a.queryByKey, predicates = _a.predicates, hasSort = _a.hasSort, hasPagination = _a.hasPagination;\n            return [4 /*yield*/, function () {\n              return __awaiter(_this, void 0, void 0, function () {\n                var keyValues, record, filtered, all;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      if (!queryByKey) return [3 /*break*/, 2];\n                      keyValues = queryByKey.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n                      return [4 /*yield*/, this.getByKey(storeName, keyValues)];\n                    case 1:\n                      record = _a.sent();\n                      return [2 /*return*/, record ? [record] : []];\n                    case 2:\n                      if (!predicates) return [3 /*break*/, 4];\n                      return [4 /*yield*/, this.filterOnPredicate(storeName, predicates)];\n                    case 3:\n                      filtered = _a.sent();\n                      return [2 /*return*/, this.inMemoryPagination(filtered, pagination)];\n                    case 4:\n                      if (!(hasSort || hasPagination)) return [3 /*break*/, 6];\n                      return [4 /*yield*/, this.getAll(storeName)];\n                    case 5:\n                      all = _a.sent();\n                      return [2 /*return*/, this.inMemoryPagination(all, pagination)];\n                    case 6:\n                      return [2 /*return*/, this.getAll(storeName)];\n                  }\n                });\n              });\n            }()];\n          case 1:\n            records = _b.sent();\n            return [4 /*yield*/, this.load(namespaceName, modelConstructor.name, records)];\n          case 2:\n            return [2 /*return*/, _b.sent()];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.getByKey = function (storeName, keyValuePath) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.db.get(keyValuePath, storeName)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.getAll = function (storeName) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.db.getAll(storeName)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.filterOnPredicate = function (storeName, predicates) {\n    return __awaiter(this, void 0, void 0, function () {\n      var predicateObjs, type, all, filtered;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            predicateObjs = predicates.predicates, type = predicates.type;\n            return [4 /*yield*/, this.getAll(storeName)];\n          case 1:\n            all = _a.sent();\n            filtered = predicateObjs ? all.filter(function (m) {\n              return validatePredicate(m, type, predicateObjs);\n            }) : all;\n            return [2 /*return*/, filtered];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.inMemoryPagination = function (records, pagination) {\n    return inMemoryPagination(records, pagination);\n  };\n  AsyncStorageAdapter.prototype.queryOne = function (modelConstructor, firstOrLast) {\n    if (firstOrLast === void 0) {\n      firstOrLast = QueryOne.FIRST;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var storeName, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            storeName = this.getStorenameForModel(modelConstructor);\n            return [4 /*yield*/, this.db.getOne(firstOrLast, storeName)];\n          case 1:\n            result = _a.sent();\n            return [2 /*return*/, result && this.modelInstanceCreator(modelConstructor, result)];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.deleteItem = function (deleteQueue) {\n    var e_3, _a, e_4, _b;\n    return __awaiter(this, void 0, void 0, function () {\n      var _c, _d, deleteItem, storeName, items, items_2, items_2_1, item, keyValuesPath, e_4_1, e_3_1;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _e.trys.push([0, 17, 18, 23]);\n            _c = __asyncValues(deleteQueue);\n            _e.label = 1;\n          case 1:\n            return [4 /*yield*/, _c.next()];\n          case 2:\n            if (!(_d = _e.sent(), !_d.done)) return [3 /*break*/, 16];\n            deleteItem = _d.value;\n            storeName = deleteItem.storeName, items = deleteItem.items;\n            _e.label = 3;\n          case 3:\n            _e.trys.push([3, 9, 10, 15]);\n            items_2 = __asyncValues(items);\n            _e.label = 4;\n          case 4:\n            return [4 /*yield*/, items_2.next()];\n          case 5:\n            if (!(items_2_1 = _e.sent(), !items_2_1.done)) return [3 /*break*/, 8];\n            item = items_2_1.value;\n            if (!item) return [3 /*break*/, 7];\n            if (!(typeof item === 'object')) return [3 /*break*/, 7];\n            keyValuesPath = this.getIndexKeyValuesPath(item);\n            return [4 /*yield*/, this.db.delete(keyValuesPath, storeName)];\n          case 6:\n            _e.sent();\n            _e.label = 7;\n          case 7:\n            return [3 /*break*/, 4];\n          case 8:\n            return [3 /*break*/, 15];\n          case 9:\n            e_4_1 = _e.sent();\n            e_4 = {\n              error: e_4_1\n            };\n            return [3 /*break*/, 15];\n          case 10:\n            _e.trys.push([10,, 13, 14]);\n            if (!(items_2_1 && !items_2_1.done && (_b = items_2.return))) return [3 /*break*/, 12];\n            return [4 /*yield*/, _b.call(items_2)];\n          case 11:\n            _e.sent();\n            _e.label = 12;\n          case 12:\n            return [3 /*break*/, 14];\n          case 13:\n            if (e_4) throw e_4.error;\n            return [7 /*endfinally*/];\n          case 14:\n            return [7 /*endfinally*/];\n          case 15:\n            return [3 /*break*/, 1];\n          case 16:\n            return [3 /*break*/, 23];\n          case 17:\n            e_3_1 = _e.sent();\n            e_3 = {\n              error: e_3_1\n            };\n            return [3 /*break*/, 23];\n          case 18:\n            _e.trys.push([18,, 21, 22]);\n            if (!(_d && !_d.done && (_a = _c.return))) return [3 /*break*/, 20];\n            return [4 /*yield*/, _a.call(_c)];\n          case 19:\n            _e.sent();\n            _e.label = 20;\n          case 20:\n            return [3 /*break*/, 22];\n          case 21:\n            if (e_3) throw e_3.error;\n            return [7 /*endfinally*/];\n          case 22:\n            return [7 /*endfinally*/];\n          case 23:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  //#region platform-specific helper methods\n  /**\n   * Retrieves concatenated primary key values from a model\n   *\n   * @param model\n   * @returns\n   */\n  AsyncStorageAdapter.prototype.getIndexKeyValuesPath = function (model) {\n    return this.getIndexKeyValuesFromModel(model).join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n  };\n  return AsyncStorageAdapter;\n}(StorageAdapterBase);\nexport { AsyncStorageAdapter };\nexport default new AsyncStorageAdapter();","map":{"version":3,"mappings":"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","names":["AsyncStorageDatabase","OpType","QueryOne","DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR","traverseModel","validatePredicate","inMemoryPagination","keysEqual","getStorename","getIndexKeys","StorageAdapterBase","__extends","AsyncStorageAdapter","db","init","_a","clear","undefined","initPromise","modelConstructor","items","length","modelName","name","namespaceName","namespaceResolver","storeName","keys","schema","namespaces","batch","item","model","this_1","modelInstanceCreator","connectedModels","getModelConstructorByModelName","keyValuesPath","getIndexKeyValuesPath","push","instance","items_1","batchSave","_b","keyArr","itemKeyValuesPath","join","get","condition","saveMetadata","connectionStoreNames","modelKeyValues","_get","fromDB","_c","validateSaveCondition","result","connectionStoreNames_1","resItem","storeName_1","itemKeyValues","map","key","fromDB_1","opType","UPDATE","INSERT","save","predicate","pagination","queryMetadata","queryByKey","predicates","hasSort","hasPagination","keyValues","getByKey","record","filterOnPredicate","filtered","getAll","all","records","load","keyValuePath","predicateObjs","type","filter","m","firstOrLast","FIRST","getStorenameForModel","getOne","deleteQueue","deleteItem","items_2","delete","_e","getIndexKeyValuesFromModel"],"sources":["/Workshop/product-metadata/guidance-for-generating-product-descriptions-with-bedrock/source/frontend/node_modules/@aws-amplify/datastore/src/storage/adapter/AsyncStorageAdapter.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport AsyncStorageDatabase from './AsyncStorageDatabase';\nimport {\n\tModelInstanceMetadata,\n\tModelPredicate,\n\tOpType,\n\tPaginationInput,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tPredicatesGroup,\n\tQueryOne,\n} from '../../types';\nimport {\n\tDEFAULT_PRIMARY_KEY_VALUE_SEPARATOR,\n\ttraverseModel,\n\tvalidatePredicate,\n\tinMemoryPagination,\n\tkeysEqual,\n\tgetStorename,\n\tgetIndexKeys,\n} from '../../util';\nimport { StorageAdapterBase } from './StorageAdapterBase';\n\nexport class AsyncStorageAdapter extends StorageAdapterBase {\n\tprotected db!: AsyncStorageDatabase;\n\n\t// no-ops for this adapter\n\tprotected async preSetUpChecks() {}\n\tprotected async preOpCheck() {}\n\n\t/**\n\t * Open AsyncStorage database\n\t * Create new DB if one doesn't exist\n\t *\n\t * Called by `StorageAdapterBase.setUp()`\n\t *\n\t * @returns AsyncStorageDatabase instance\n\t */\n\tprotected async initDb(): Promise<AsyncStorageDatabase> {\n\t\tconst db = new AsyncStorageDatabase();\n\t\tawait db.init();\n\t\treturn db;\n\t}\n\n\tasync clear(): Promise<void> {\n\t\tawait this.db.clear();\n\n\t\tthis.db = undefined!;\n\t\tthis.initPromise = undefined!;\n\t}\n\n\tasync batchSave<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<any>,\n\t\titems: ModelInstanceMetadata[]\n\t): Promise<[T, OpType][]> {\n\t\tif (items.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst modelName = modelConstructor.name;\n\t\tconst namespaceName = this.namespaceResolver(modelConstructor);\n\t\tconst storeName = getStorename(namespaceName, modelName);\n\t\tconst keys = getIndexKeys(this.schema.namespaces[namespaceName], modelName);\n\t\tconst batch: ModelInstanceMetadata[] = [];\n\n\t\tfor (const item of items) {\n\t\t\tconst model = this.modelInstanceCreator(modelConstructor, item);\n\n\t\t\tconst connectedModels = traverseModel(\n\t\t\t\tmodelName,\n\t\t\t\tmodel,\n\t\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\t\tthis.modelInstanceCreator,\n\t\t\t\tthis.getModelConstructorByModelName\n\t\t\t);\n\n\t\t\tconst keyValuesPath = this.getIndexKeyValuesPath(model);\n\n\t\t\tconst { instance } = connectedModels.find(({ instance }) => {\n\t\t\t\tconst instanceKeyValuesPath = this.getIndexKeyValuesPath(instance);\n\t\t\t\treturn keysEqual([instanceKeyValuesPath], [keyValuesPath]);\n\t\t\t})!;\n\n\t\t\tbatch.push(instance);\n\t\t}\n\n\t\treturn await this.db.batchSave(storeName, batch, keys);\n\t}\n\n\tprotected async _get<T>(storeName: string, keyArr: string[]): Promise<T> {\n\t\tconst itemKeyValuesPath: string = keyArr.join(\n\t\t\tDEFAULT_PRIMARY_KEY_VALUE_SEPARATOR\n\t\t);\n\n\t\treturn <T>await this.db.get(itemKeyValuesPath, storeName);\n\t}\n\n\tasync save<T extends PersistentModel>(\n\t\tmodel: T,\n\t\tcondition?: ModelPredicate<T>\n\t): Promise<[T, OpType.INSERT | OpType.UPDATE][]> {\n\t\tconst { storeName, connectionStoreNames, modelKeyValues } =\n\t\t\tthis.saveMetadata(model);\n\n\t\tconst fromDB = await this._get(storeName, modelKeyValues);\n\n\t\tthis.validateSaveCondition(condition, fromDB);\n\n\t\tconst result: [T, OpType.INSERT | OpType.UPDATE][] = [];\n\t\tfor await (const resItem of connectionStoreNames) {\n\t\t\tconst { storeName, item, instance, keys } = resItem;\n\n\t\t\tconst itemKeyValues: string[] = keys.map(key => item[key]);\n\n\t\t\tconst fromDB = <T>await this._get(storeName, itemKeyValues);\n\t\t\tconst opType: OpType = fromDB ? OpType.UPDATE : OpType.INSERT;\n\n\t\t\tif (\n\t\t\t\tkeysEqual(itemKeyValues, modelKeyValues) ||\n\t\t\t\topType === OpType.INSERT\n\t\t\t) {\n\t\t\t\tawait this.db.save(\n\t\t\t\t\titem,\n\t\t\t\t\tstoreName,\n\t\t\t\t\tkeys,\n\t\t\t\t\titemKeyValues.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR)\n\t\t\t\t);\n\n\t\t\t\tresult.push([instance, opType]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tasync query<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tpredicate?: ModelPredicate<T>,\n\t\tpagination?: PaginationInput<T>\n\t): Promise<T[]> {\n\t\tconst {\n\t\t\tstoreName,\n\t\t\tnamespaceName,\n\t\t\tqueryByKey,\n\t\t\tpredicates,\n\t\t\thasSort,\n\t\t\thasPagination,\n\t\t} = this.queryMetadata(modelConstructor, predicate, pagination);\n\n\t\tconst records: T[] = (await (async () => {\n\t\t\tif (queryByKey) {\n\t\t\t\tconst keyValues = queryByKey.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n\t\t\t\tconst record = await this.getByKey(storeName, keyValues);\n\t\t\t\treturn record ? [record] : [];\n\t\t\t}\n\n\t\t\tif (predicates) {\n\t\t\t\tconst filtered = await this.filterOnPredicate(storeName, predicates);\n\t\t\t\treturn this.inMemoryPagination(filtered, pagination);\n\t\t\t}\n\n\t\t\tif (hasSort || hasPagination) {\n\t\t\t\tconst all = await this.getAll(storeName);\n\t\t\t\treturn this.inMemoryPagination(all, pagination);\n\t\t\t}\n\n\t\t\treturn this.getAll(storeName);\n\t\t})()) as T[];\n\n\t\treturn await this.load(namespaceName, modelConstructor.name, records);\n\t}\n\n\tprivate async getByKey<T extends PersistentModel>(\n\t\tstoreName: string,\n\t\tkeyValuePath: string\n\t): Promise<T> {\n\t\treturn <T>await this.db.get(keyValuePath, storeName);\n\t}\n\n\tprivate async getAll<T extends PersistentModel>(\n\t\tstoreName: string\n\t): Promise<T[]> {\n\t\treturn await this.db.getAll(storeName);\n\t}\n\n\tprivate async filterOnPredicate<T extends PersistentModel>(\n\t\tstoreName: string,\n\t\tpredicates: PredicatesGroup<T>\n\t) {\n\t\tconst { predicates: predicateObjs, type } = predicates;\n\n\t\tconst all = <T[]>await this.getAll(storeName);\n\n\t\tconst filtered = predicateObjs\n\t\t\t? all.filter(m => validatePredicate(m, type, predicateObjs))\n\t\t\t: all;\n\n\t\treturn filtered;\n\t}\n\n\tprivate inMemoryPagination<T extends PersistentModel>(\n\t\trecords: T[],\n\t\tpagination?: PaginationInput<T>\n\t): T[] {\n\t\treturn inMemoryPagination(records, pagination);\n\t}\n\n\tasync queryOne<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tfirstOrLast: QueryOne = QueryOne.FIRST\n\t): Promise<T | undefined> {\n\t\tconst storeName = this.getStorenameForModel(modelConstructor);\n\t\tconst result = <T>await this.db.getOne(firstOrLast, storeName);\n\n\t\treturn result && this.modelInstanceCreator(modelConstructor, result);\n\t}\n\n\tprotected async deleteItem<T extends PersistentModel>(\n\t\tdeleteQueue?: { storeName: string; items: T[] | IDBValidKey[] }[]\n\t) {\n\t\tfor await (const deleteItem of deleteQueue!) {\n\t\t\tconst { storeName, items } = deleteItem;\n\n\t\t\tfor await (const item of items) {\n\t\t\t\tif (item) {\n\t\t\t\t\tif (typeof item === 'object') {\n\t\t\t\t\t\tconst keyValuesPath: string = this.getIndexKeyValuesPath(item as T);\n\t\t\t\t\t\tawait this.db.delete(keyValuesPath, storeName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//#region platform-specific helper methods\n\n\t/**\n\t * Retrieves concatenated primary key values from a model\n\t *\n\t * @param model\n\t * @returns\n\t */\n\tprivate getIndexKeyValuesPath<T extends PersistentModel>(model: T): string {\n\t\treturn this.getIndexKeyValuesFromModel(model).join(\n\t\t\tDEFAULT_PRIMARY_KEY_VALUE_SEPARATOR\n\t\t);\n\t}\n\n\t//#endregion\n}\n\nexport default new AsyncStorageAdapter();\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}