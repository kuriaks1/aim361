{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __rest, __values } from \"tslib\";\nimport { InternalAPI } from '@aws-amplify/api/internals';\nimport { Category, ConsoleLogger as Logger, DataStoreAction, jitteredBackoff, NonRetryableError, retry, BackgroundProcessManager } from '@aws-amplify/core';\nimport Observable from 'zen-observable-ts';\nimport { DISCARD, isModelFieldType, isTargetNameAssociation, OpType, ProcessName } from '../../types';\nimport { extractTargetNamesFromSrc, USER, ID } from '../../util';\nimport { buildGraphQLOperation, createMutationInstanceFromModelOperation, getModelAuthModes, TransformerMutationType, getTokenForCustomAuth } from '../utils';\nimport { getMutationErrorType } from './errorMaps';\nvar MAX_ATTEMPTS = 10;\nvar logger = new Logger('DataStore');\nvar MutationProcessor = /** @class */function () {\n  function MutationProcessor(schema, storage, userClasses, outbox, modelInstanceCreator, MutationEvent, amplifyConfig, authModeStrategy, errorHandler, conflictHandler, amplifyContext) {\n    if (amplifyConfig === void 0) {\n      amplifyConfig = {};\n    }\n    this.schema = schema;\n    this.storage = storage;\n    this.userClasses = userClasses;\n    this.outbox = outbox;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.MutationEvent = MutationEvent;\n    this.amplifyConfig = amplifyConfig;\n    this.authModeStrategy = authModeStrategy;\n    this.errorHandler = errorHandler;\n    this.conflictHandler = conflictHandler;\n    this.amplifyContext = amplifyContext;\n    this.typeQuery = new WeakMap();\n    this.processing = false;\n    this.runningProcesses = new BackgroundProcessManager();\n    this.amplifyContext.InternalAPI = this.amplifyContext.InternalAPI || InternalAPI;\n    this.generateQueries();\n  }\n  MutationProcessor.prototype.generateQueries = function () {\n    var _this = this;\n    Object.values(this.schema.namespaces).forEach(function (namespace) {\n      Object.values(namespace.models).filter(function (_a) {\n        var syncable = _a.syncable;\n        return syncable;\n      }).forEach(function (model) {\n        var _a = __read(buildGraphQLOperation(namespace, model, 'CREATE'), 1),\n          createMutation = _a[0];\n        var _b = __read(buildGraphQLOperation(namespace, model, 'UPDATE'), 1),\n          updateMutation = _b[0];\n        var _c = __read(buildGraphQLOperation(namespace, model, 'DELETE'), 1),\n          deleteMutation = _c[0];\n        _this.typeQuery.set(model, [createMutation, updateMutation, deleteMutation]);\n      });\n    });\n  };\n  MutationProcessor.prototype.isReady = function () {\n    return this.observer !== undefined;\n  };\n  MutationProcessor.prototype.start = function () {\n    var _this = this;\n    this.runningProcesses = new BackgroundProcessManager();\n    var observable = new Observable(function (observer) {\n      _this.observer = observer;\n      try {\n        _this.resume();\n      } catch (error) {\n        logger.error('mutations processor start error', error);\n        throw error;\n      }\n      return _this.runningProcesses.addCleaner(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            // The observer has unsubscribed and/or `stop()` has been called.\n            this.removeObserver();\n            this.pause();\n            return [2 /*return*/];\n          });\n        });\n      });\n    });\n\n    return observable;\n  };\n  MutationProcessor.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.removeObserver();\n            return [4 /*yield*/, this.runningProcesses.close()];\n          case 1:\n            _a.sent();\n            return [4 /*yield*/, this.runningProcesses.open()];\n          case 2:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  MutationProcessor.prototype.removeObserver = function () {\n    var _a, _b;\n    (_b = (_a = this.observer) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);\n    this.observer = undefined;\n  };\n  MutationProcessor.prototype.resume = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.runningProcesses.isOpen && this.runningProcesses.add(function (onTerminate) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var head, namespaceName, _loop_1, this_1, _a;\n                var _this = this;\n                var _b, _c;\n                return __generator(this, function (_d) {\n                  switch (_d.label) {\n                    case 0:\n                      if (this.processing || !this.isReady() || !this.runningProcesses.isOpen) {\n                        return [2 /*return*/];\n                      }\n\n                      this.processing = true;\n                      namespaceName = USER;\n                      _loop_1 = function () {\n                        var model, operation, data, condition, modelConstructor, result, opName, modelDefinition, modelAuthModes, operationAuthModes_1, authModeAttempts_1, authModeRetry_1, error_1, record, hasMore;\n                        var _a;\n                        return __generator(this, function (_b) {\n                          switch (_b.label) {\n                            case 0:\n                              model = head.model, operation = head.operation, data = head.data, condition = head.condition;\n                              modelConstructor = this_1.userClasses[model];\n                              result = undefined;\n                              opName = undefined;\n                              modelDefinition = undefined;\n                              _b.label = 1;\n                            case 1:\n                              _b.trys.push([1, 4,, 5]);\n                              return [4 /*yield*/, getModelAuthModes({\n                                authModeStrategy: this_1.authModeStrategy,\n                                defaultAuthMode: this_1.amplifyConfig.aws_appsync_authenticationType,\n                                modelName: model,\n                                schema: this_1.schema\n                              })];\n                            case 2:\n                              modelAuthModes = _b.sent();\n                              operationAuthModes_1 = modelAuthModes[operation.toUpperCase()];\n                              authModeAttempts_1 = 0;\n                              authModeRetry_1 = function () {\n                                return __awaiter(_this, void 0, void 0, function () {\n                                  var response, error_2, e_1;\n                                  return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                      case 0:\n                                        _a.trys.push([0, 2,, 9]);\n                                        logger.debug(\"Attempting mutation with authMode: \" + operationAuthModes_1[authModeAttempts_1]);\n                                        return [4 /*yield*/, this.jitteredRetry(namespaceName, model, operation, data, condition, modelConstructor, this.MutationEvent, head, operationAuthModes_1[authModeAttempts_1], onTerminate)];\n                                      case 1:\n                                        response = _a.sent();\n                                        logger.debug(\"Mutation sent successfully with authMode: \" + operationAuthModes_1[authModeAttempts_1]);\n                                        return [2 /*return*/, response];\n                                      case 2:\n                                        error_2 = _a.sent();\n                                        authModeAttempts_1++;\n                                        if (!(authModeAttempts_1 >= operationAuthModes_1.length)) return [3 /*break*/, 7];\n                                        logger.debug(\"Mutation failed with authMode: \" + operationAuthModes_1[authModeAttempts_1 - 1]);\n                                        _a.label = 3;\n                                      case 3:\n                                        _a.trys.push([3, 5,, 6]);\n                                        return [4 /*yield*/, this.errorHandler({\n                                          recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                                          localModel: null,\n                                          message: error_2.message,\n                                          model: modelConstructor.name,\n                                          operation: opName,\n                                          errorType: getMutationErrorType(error_2),\n                                          process: ProcessName.sync,\n                                          remoteModel: null,\n                                          cause: error_2\n                                        })];\n                                      case 4:\n                                        _a.sent();\n                                        return [3 /*break*/, 6];\n                                      case 5:\n                                        e_1 = _a.sent();\n                                        logger.error('Mutation error handler failed with:', e_1);\n                                        return [3 /*break*/, 6];\n                                      case 6:\n                                        throw error_2;\n                                      case 7:\n                                        logger.debug(\"Mutation failed with authMode: \" + operationAuthModes_1[authModeAttempts_1 - 1] + \". Retrying with authMode: \" + operationAuthModes_1[authModeAttempts_1]);\n                                        return [4 /*yield*/, authModeRetry_1()];\n                                      case 8:\n                                        return [2 /*return*/, _a.sent()];\n                                      case 9:\n                                        return [2 /*return*/];\n                                    }\n                                  });\n                                });\n                              };\n\n                              return [4 /*yield*/, authModeRetry_1()];\n                            case 3:\n                              _a = __read.apply(void 0, [_b.sent(), 3]), result = _a[0], opName = _a[1], modelDefinition = _a[2];\n                              return [3 /*break*/, 5];\n                            case 4:\n                              error_1 = _b.sent();\n                              if (error_1.message === 'Offline' || error_1.message === 'RetryMutation') {\n                                return [2 /*return*/, \"continue\"];\n                              }\n                              return [3 /*break*/, 5];\n                            case 5:\n                              if (!(result === undefined)) return [3 /*break*/, 7];\n                              logger.debug('done retrying');\n                              return [4 /*yield*/, this_1.storage.runExclusive(function (storage) {\n                                return __awaiter(_this, void 0, void 0, function () {\n                                  return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                      case 0:\n                                        return [4 /*yield*/, this.outbox.dequeue(storage)];\n                                      case 1:\n                                        _a.sent();\n                                        return [2 /*return*/];\n                                    }\n                                  });\n                                });\n                              })];\n\n                            case 6:\n                              _b.sent();\n                              return [2 /*return*/, \"continue\"];\n                            case 7:\n                              record = result.data[opName];\n                              hasMore = false;\n                              return [4 /*yield*/, this_1.storage.runExclusive(function (storage) {\n                                return __awaiter(_this, void 0, void 0, function () {\n                                  return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                      case 0:\n                                        // using runExclusive to prevent possible race condition\n                                        // when another record gets enqueued between dequeue and peek\n                                        return [4 /*yield*/, this.outbox.dequeue(storage, record, operation)];\n                                      case 1:\n                                        // using runExclusive to prevent possible race condition\n                                        // when another record gets enqueued between dequeue and peek\n                                        _a.sent();\n                                        return [4 /*yield*/, this.outbox.peek(storage)];\n                                      case 2:\n                                        hasMore = _a.sent() !== undefined;\n                                        return [2 /*return*/];\n                                    }\n                                  });\n                                });\n                              })];\n\n                            case 8:\n                              _b.sent();\n                              (_c = (_b = this_1.observer) === null || _b === void 0 ? void 0 : _b.next) === null || _c === void 0 ? void 0 : _c.call(_b, {\n                                operation: operation,\n                                modelDefinition: modelDefinition,\n                                model: record,\n                                hasMore: hasMore\n                              });\n                              return [2 /*return*/];\n                          }\n                        });\n                      };\n\n                      this_1 = this;\n                      _d.label = 1;\n                    case 1:\n                      _a = this.processing && this.runningProcesses.isOpen;\n                      if (!_a) return [3 /*break*/, 3];\n                      return [4 /*yield*/, this.outbox.peek(this.storage)];\n                    case 2:\n                      _a = (head = _d.sent()) !== undefined;\n                      _d.label = 3;\n                    case 3:\n                      if (!_a) return [3 /*break*/, 5];\n                      return [5 /*yield**/, _loop_1()];\n                    case 4:\n                      _d.sent();\n                      return [3 /*break*/, 1];\n                    case 5:\n                      // pauses itself\n                      this.pause();\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            }, 'mutation resume loop')];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  MutationProcessor.prototype.jitteredRetry = function (namespaceName, model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent, authMode, onTerminate) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, retry(function (model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var _a, query, variables, graphQLCondition, opName, modelDefinition, authToken, tryWith, attempt, opType, customUserAgentDetails, result, err_1, _b, error, _c, _d, code, retryWith, err_2, _e, _f, opName_1, query_1, authToken_1, serverData, namespace, updatedMutation;\n                var _g;\n                return __generator(this, function (_h) {\n                  switch (_h.label) {\n                    case 0:\n                      _a = __read(this.createQueryVariables(namespaceName, model, operation, data, condition), 5), query = _a[0], variables = _a[1], graphQLCondition = _a[2], opName = _a[3], modelDefinition = _a[4];\n                      return [4 /*yield*/, getTokenForCustomAuth(authMode, this.amplifyConfig)];\n                    case 1:\n                      authToken = _h.sent();\n                      tryWith = {\n                        query: query,\n                        variables: variables,\n                        authMode: authMode,\n                        authToken: authToken\n                      };\n                      attempt = 0;\n                      opType = this.opTypeFromTransformerOperation(operation);\n                      customUserAgentDetails = {\n                        category: Category.DataStore,\n                        action: DataStoreAction.GraphQl\n                      };\n                      _h.label = 2;\n                    case 2:\n                      _h.trys.push([2, 4,, 17]);\n                      return [4 /*yield*/, this.amplifyContext.InternalAPI.graphql(tryWith, undefined, customUserAgentDetails)];\n                    case 3:\n                      result = _h.sent();\n                      // Use `as any` because TypeScript doesn't seem to like passing tuples\n                      // through generic params.\n                      return [2 /*return*/, [result, opName, modelDefinition]];\n                    case 4:\n                      err_1 = _h.sent();\n                      if (!(err_1.errors && err_1.errors.length > 0)) return [3 /*break*/, 15];\n                      _b = __read(err_1.errors, 1), error = _b[0];\n                      _c = error.originalError, _d = (_c === void 0 ? {} : _c).code, code = _d === void 0 ? null : _d;\n                      if (error.errorType === 'Unauthorized') {\n                        throw new NonRetryableError('Unauthorized');\n                      }\n                      if (error.message === 'Network Error' || code === 'ECONNABORTED' // refers to axios timeout error caused by device's bad network condition\n                      ) {\n                        if (!this.processing) {\n                          throw new NonRetryableError('Offline');\n                        }\n                        // TODO: Check errors on different env (react-native or other browsers)\n                        throw new Error('Network Error');\n                      }\n                      if (!(error.errorType === 'ConflictUnhandled')) return [3 /*break*/, 13];\n                      // TODO: add on ConflictConditionalCheck error query last from server\n                      attempt++;\n                      retryWith = void 0;\n                      if (!(attempt > MAX_ATTEMPTS)) return [3 /*break*/, 5];\n                      retryWith = DISCARD;\n                      return [3 /*break*/, 8];\n                    case 5:\n                      _h.trys.push([5, 7,, 8]);\n                      return [4 /*yield*/, this.conflictHandler({\n                        modelConstructor: modelConstructor,\n                        localModel: this.modelInstanceCreator(modelConstructor, variables.input),\n                        remoteModel: this.modelInstanceCreator(modelConstructor, error.data),\n                        operation: opType,\n                        attempts: attempt\n                      })];\n                    case 6:\n                      retryWith = _h.sent();\n                      return [3 /*break*/, 8];\n                    case 7:\n                      err_2 = _h.sent();\n                      logger.warn('conflict trycatch', err_2);\n                      return [3 /*break*/, 17];\n                    case 8:\n                      if (!(retryWith === DISCARD)) return [3 /*break*/, 11];\n                      _e = __read(buildGraphQLOperation(this.schema.namespaces[namespaceName], modelDefinition, 'GET'), 1), _f = __read(_e[0], 3), opName_1 = _f[1], query_1 = _f[2];\n                      return [4 /*yield*/, getTokenForCustomAuth(authMode, this.amplifyConfig)];\n                    case 9:\n                      authToken_1 = _h.sent();\n                      return [4 /*yield*/, this.amplifyContext.InternalAPI.graphql({\n                        query: query_1,\n                        variables: {\n                          id: variables.input.id\n                        },\n                        authMode: authMode,\n                        authToken: authToken_1\n                      }, undefined, customUserAgentDetails)];\n                    case 10:\n                      serverData = _h.sent();\n                      // onTerminate cancel graphql()\n                      return [2 /*return*/, [serverData, opName_1, modelDefinition]];\n                    case 11:\n                      namespace = this.schema.namespaces[namespaceName];\n                      updatedMutation = createMutationInstanceFromModelOperation(namespace.relationships, modelDefinition, opType, modelConstructor, retryWith, graphQLCondition, MutationEvent, this.modelInstanceCreator, mutationEvent.id);\n                      return [4 /*yield*/, this.storage.save(updatedMutation)];\n                    case 12:\n                      _h.sent();\n                      throw new NonRetryableError('RetryMutation');\n                    case 13:\n                      try {\n                        this.errorHandler({\n                          recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                          localModel: variables.input,\n                          message: error.message,\n                          operation: operation,\n                          errorType: getMutationErrorType(error),\n                          errorInfo: error.errorInfo,\n                          process: ProcessName.mutate,\n                          cause: error,\n                          remoteModel: error.data ? this.modelInstanceCreator(modelConstructor, error.data) : null\n                        });\n                      } catch (err) {\n                        logger.warn('Mutation error handler failed with:', err);\n                      } finally {\n                        // Return empty tuple, dequeues the mutation\n                        return [2 /*return*/, error.data ? [{\n                          data: (_g = {}, _g[opName] = error.data, _g)\n                        }, opName, modelDefinition] : []];\n                      }\n                      _h.label = 14;\n                    case 14:\n                      return [3 /*break*/, 16];\n                    case 15:\n                      // Catch-all for client-side errors that don't come back in the `GraphQLError` format.\n                      // These errors should not be retried.\n                      throw new NonRetryableError(err_1);\n                    case 16:\n                      return [3 /*break*/, 17];\n                    case 17:\n                      if (tryWith) return [3 /*break*/, 2];\n                      _h.label = 18;\n                    case 18:\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            }, [model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent], safeJitteredBackoff, onTerminate)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  MutationProcessor.prototype.createQueryVariables = function (namespaceName, model, operation, data, condition) {\n    var e_2, _a, e_3, _b, e_4, _c;\n    var _d, _e;\n    var modelDefinition = this.schema.namespaces[namespaceName].models[model];\n    var primaryKey = this.schema.namespaces[namespaceName].keys[model].primaryKey;\n    var auth = (_d = modelDefinition.attributes) === null || _d === void 0 ? void 0 : _d.find(function (a) {\n      return a.type === 'auth';\n    });\n    var ownerFields = ((_e = auth === null || auth === void 0 ? void 0 : auth.properties) === null || _e === void 0 ? void 0 : _e.rules.map(function (rule) {\n      return rule.ownerField;\n    }).filter(function (f) {\n      return f;\n    })) || ['owner'];\n    var queriesTuples = this.typeQuery.get(modelDefinition);\n    var _f = __read(queriesTuples.find(function (_a) {\n        var _b = __read(_a, 1),\n          transformerMutationType = _b[0];\n        return transformerMutationType === operation;\n      }), 3),\n      opName = _f[1],\n      query = _f[2];\n    var _g = JSON.parse(data),\n      _version = _g._version,\n      parsedData = __rest(_g, [\"_version\"]);\n    // include all the fields that comprise a custom PK if one is specified\n    var deleteInput = {};\n    if (primaryKey === null || primaryKey === void 0 ? void 0 : primaryKey.length) {\n      try {\n        for (var primaryKey_1 = __values(primaryKey), primaryKey_1_1 = primaryKey_1.next(); !primaryKey_1_1.done; primaryKey_1_1 = primaryKey_1.next()) {\n          var pkField = primaryKey_1_1.value;\n          deleteInput[pkField] = parsedData[pkField];\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (primaryKey_1_1 && !primaryKey_1_1.done && (_a = primaryKey_1.return)) _a.call(primaryKey_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    } else {\n      deleteInput[ID] = parsedData.id;\n    }\n    var mutationInput;\n    if (operation === TransformerMutationType.DELETE) {\n      // For DELETE mutations, only the key(s) are included in the input\n      mutationInput = deleteInput;\n    } else {\n      // Otherwise, we construct the mutation input with the following logic\n      mutationInput = {};\n      var modelFields = Object.values(modelDefinition.fields);\n      try {\n        for (var modelFields_1 = __values(modelFields), modelFields_1_1 = modelFields_1.next(); !modelFields_1_1.done; modelFields_1_1 = modelFields_1.next()) {\n          var _h = modelFields_1_1.value,\n            name_1 = _h.name,\n            type = _h.type,\n            association = _h.association,\n            isReadOnly = _h.isReadOnly;\n          // omit readonly fields. cloud storage doesn't need them and won't take them!\n          if (isReadOnly) {\n            continue;\n          }\n          // omit owner fields if it's `null`. cloud storage doesn't allow it.\n          if (ownerFields.includes(name_1) && parsedData[name_1] === null) {\n            continue;\n          }\n          // model fields should be stripped out from the input\n          if (isModelFieldType(type)) {\n            // except for belongs to relations - we need to replace them with the correct foreign key(s)\n            if (isTargetNameAssociation(association) && association.connectionType === 'BELONGS_TO') {\n              var targetNames = extractTargetNamesFromSrc(association);\n              if (targetNames) {\n                try {\n                  // instead of including the connected model itself, we add its key(s) to the mutation input\n                  for (var targetNames_1 = (e_4 = void 0, __values(targetNames)), targetNames_1_1 = targetNames_1.next(); !targetNames_1_1.done; targetNames_1_1 = targetNames_1.next()) {\n                    var targetName = targetNames_1_1.value;\n                    mutationInput[targetName] = parsedData[targetName];\n                  }\n                } catch (e_4_1) {\n                  e_4 = {\n                    error: e_4_1\n                  };\n                } finally {\n                  try {\n                    if (targetNames_1_1 && !targetNames_1_1.done && (_c = targetNames_1.return)) _c.call(targetNames_1);\n                  } finally {\n                    if (e_4) throw e_4.error;\n                  }\n                }\n              }\n            }\n            continue;\n          }\n          // scalar fields / non-model types\n          if (operation === TransformerMutationType.UPDATE) {\n            if (!parsedData.hasOwnProperty(name_1)) {\n              // for update mutations - strip out a field if it's unchanged\n              continue;\n            }\n          }\n          // all other fields are added to the input object\n          mutationInput[name_1] = parsedData[name_1];\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (modelFields_1_1 && !modelFields_1_1.done && (_b = modelFields_1.return)) _b.call(modelFields_1);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    }\n    // Build mutation variables input object\n    var input = __assign(__assign({}, mutationInput), {\n      _version: _version\n    });\n    var graphQLCondition = JSON.parse(condition);\n    var variables = __assign({\n      input: input\n    }, operation === TransformerMutationType.CREATE ? {} : {\n      condition: Object.keys(graphQLCondition).length > 0 ? graphQLCondition : null\n    });\n    return [query, variables, graphQLCondition, opName, modelDefinition];\n  };\n  MutationProcessor.prototype.opTypeFromTransformerOperation = function (operation) {\n    switch (operation) {\n      case TransformerMutationType.CREATE:\n        return OpType.INSERT;\n      case TransformerMutationType.DELETE:\n        return OpType.DELETE;\n      case TransformerMutationType.UPDATE:\n        return OpType.UPDATE;\n      case TransformerMutationType.GET:\n        // Intentionally blank\n        break;\n      default:\n        throw new Error(\"Invalid operation \" + operation);\n    }\n    // because it makes TS happy ...\n    return undefined;\n  };\n  MutationProcessor.prototype.pause = function () {\n    this.processing = false;\n  };\n  return MutationProcessor;\n}();\nvar MAX_RETRY_DELAY_MS = 5 * 60 * 1000;\nvar originalJitteredBackoff = jitteredBackoff(MAX_RETRY_DELAY_MS);\n/**\n * @private\n * Internal use of Amplify only.\n *\n * Wraps the jittered backoff calculation to retry Network Errors indefinitely.\n * Backs off according to original jittered retry logic until the original retry\n * logic hits its max. After this occurs, if the error is a Network Error, we\n * ignore the attempt count and return MAX_RETRY_DELAY_MS to retry forever (until\n * the request succeeds).\n *\n * @param attempt ignored\n * @param _args ignored\n * @param error tested to see if `.message` is 'Network Error'\n * @returns number | false :\n */\nexport var safeJitteredBackoff = function (attempt, _args, error) {\n  var attemptResult = originalJitteredBackoff(attempt);\n  // If this is the last attempt and it is a network error, we retry indefinitively every 5 minutes\n  if (attemptResult === false && (error === null || error === void 0 ? void 0 : error.message) === 'Network Error') {\n    return MAX_RETRY_DELAY_MS;\n  }\n  return attemptResult;\n};\nexport { MutationProcessor };","map":{"version":3,"mappings":"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","names":["InternalAPI","Category","ConsoleLogger","Logger","DataStoreAction","jitteredBackoff","NonRetryableError","retry","BackgroundProcessManager","Observable","DISCARD","isModelFieldType","isTargetNameAssociation","OpType","ProcessName","extractTargetNamesFromSrc","USER","ID","buildGraphQLOperation","createMutationInstanceFromModelOperation","getModelAuthModes","TransformerMutationType","getTokenForCustomAuth","getMutationErrorType","MAX_ATTEMPTS","logger","schema","storage","userClasses","outbox","modelInstanceCreator","MutationEvent","amplifyConfig","authModeStrategy","errorHandler","conflictHandler","amplifyContext","WeakMap","generateQueries","MutationProcessor","Object","values","namespaces","forEach","namespace","models","filter","_a","syncable","createMutation","updateMutation","deleteMutation","_this","typeQuery","set","model","observer","undefined","runningProcesses","observable","resume","error","addCleaner","removeObserver","pause","close","open","complete","isOpen","add","onTerminate","processing","isReady","namespaceName","head","operation","data","condition","modelConstructor","this_1","result","opName","modelDefinition","defaultAuthMode","aws_appsync_authenticationType","modelName","modelAuthModes","_b","operationAuthModes_1","toUpperCase","authModeAttempts_1","authModeRetry_1","debug","jitteredRetry","response","length","recoverySuggestion","localModel","message","error_2","name","errorType","process","sync","remoteModel","cause","e_1","error_1","runExclusive","dequeue","record","hasMore","peek","next","_d","mutationEvent","authMode","createQueryVariables","query","variables","graphQLCondition","authToken","_h","tryWith","attempt","opType","opTypeFromTransformerOperation","customUserAgentDetails","category","DataStore","action","GraphQl","graphql","err_1","errors","_c","code","Error","retryWith","input","attempts","warn","err_2","_e","_f","opName_1","query_1","authToken_1","id","serverData","updatedMutation","relationships","save","errorInfo","mutate","err","_g","safeJitteredBackoff","auth","attributes","find","type","ownerFields","properties","rules","map","ownerField","queriesTuples","get","_version","parsedData","deleteInput","primaryKey","pkField","mutationInput","DELETE","modelFields","fields","name_1","association","isReadOnly","includes","connectionType","targetNames","targetName","UPDATE","hasOwnProperty","JSON","parse","CREATE","keys","INSERT","GET","MAX_RETRY_DELAY_MS","originalJitteredBackoff","_args","attemptResult"],"sources":["/Workshop/product-metadata/guidance-for-generating-product-descriptions-with-bedrock/source/frontend/node_modules/@aws-amplify/datastore/src/sync/processors/mutation.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { GraphQLResult, GRAPHQL_AUTH_MODE } from '@aws-amplify/api';\nimport { InternalAPI } from '@aws-amplify/api/internals';\nimport {\n\tCategory,\n\tConsoleLogger as Logger,\n\tCustomUserAgentDetails,\n\tDataStoreAction,\n\tjitteredBackoff,\n\tNonRetryableError,\n\tretry,\n\tBackgroundProcessManager,\n} from '@aws-amplify/core';\nimport Observable, { ZenObservable } from 'zen-observable-ts';\nimport { MutationEvent } from '../';\nimport { ModelInstanceCreator } from '../../datastore/datastore';\nimport { ExclusiveStorage as Storage } from '../../storage/storage';\nimport {\n\tAuthModeStrategy,\n\tConflictHandler,\n\tDISCARD,\n\tErrorHandler,\n\tGraphQLCondition,\n\tInternalSchema,\n\tisModelFieldType,\n\tisTargetNameAssociation,\n\tModelInstanceMetadata,\n\tOpType,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tSchemaModel,\n\tTypeConstructorMap,\n\tProcessName,\n\tAmplifyContext,\n} from '../../types';\nimport { extractTargetNamesFromSrc, USER, ID } from '../../util';\nimport { MutationEventOutbox } from '../outbox';\nimport {\n\tbuildGraphQLOperation,\n\tcreateMutationInstanceFromModelOperation,\n\tgetModelAuthModes,\n\tTransformerMutationType,\n\tgetTokenForCustomAuth,\n} from '../utils';\nimport { getMutationErrorType } from './errorMaps';\n\nconst MAX_ATTEMPTS = 10;\n\nconst logger = new Logger('DataStore');\n\ntype MutationProcessorEvent = {\n\toperation: TransformerMutationType;\n\tmodelDefinition: SchemaModel;\n\tmodel: PersistentModel;\n\thasMore: boolean;\n};\n\nclass MutationProcessor {\n\t/**\n\t * The observer that receives messages when mutations are successfully completed\n\t * against cloud storage.\n\t *\n\t * A value of `undefined` signals that the sync has either been stopped or has not\n\t * yet started. In this case, `isReady()` will be `false` and `resume()` will exit\n\t * early.\n\t */\n\tprivate observer?: ZenObservable.Observer<MutationProcessorEvent>;\n\tprivate readonly typeQuery = new WeakMap<\n\t\tSchemaModel,\n\t\t[TransformerMutationType, string, string][]\n\t>();\n\tprivate processing: boolean = false;\n\n\tprivate runningProcesses = new BackgroundProcessManager();\n\n\tconstructor(\n\t\tprivate readonly schema: InternalSchema,\n\t\tprivate readonly storage: Storage,\n\t\tprivate readonly userClasses: TypeConstructorMap,\n\t\tprivate readonly outbox: MutationEventOutbox,\n\t\tprivate readonly modelInstanceCreator: ModelInstanceCreator,\n\t\tprivate readonly MutationEvent: PersistentModelConstructor<MutationEvent>,\n\t\tprivate readonly amplifyConfig: Record<string, any> = {},\n\t\tprivate readonly authModeStrategy: AuthModeStrategy,\n\t\tprivate readonly errorHandler: ErrorHandler,\n\t\tprivate readonly conflictHandler: ConflictHandler,\n\t\tprivate readonly amplifyContext: AmplifyContext\n\t) {\n\t\tthis.amplifyContext.InternalAPI =\n\t\t\tthis.amplifyContext.InternalAPI || InternalAPI;\n\t\tthis.generateQueries();\n\t}\n\n\tprivate generateQueries() {\n\t\tObject.values(this.schema.namespaces).forEach(namespace => {\n\t\t\tObject.values(namespace.models)\n\t\t\t\t.filter(({ syncable }) => syncable)\n\t\t\t\t.forEach(model => {\n\t\t\t\t\tconst [createMutation] = buildGraphQLOperation(\n\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t'CREATE'\n\t\t\t\t\t);\n\t\t\t\t\tconst [updateMutation] = buildGraphQLOperation(\n\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t'UPDATE'\n\t\t\t\t\t);\n\t\t\t\t\tconst [deleteMutation] = buildGraphQLOperation(\n\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t'DELETE'\n\t\t\t\t\t);\n\n\t\t\t\t\tthis.typeQuery.set(model, [\n\t\t\t\t\t\tcreateMutation,\n\t\t\t\t\t\tupdateMutation,\n\t\t\t\t\t\tdeleteMutation,\n\t\t\t\t\t]);\n\t\t\t\t});\n\t\t});\n\t}\n\n\tprivate isReady() {\n\t\treturn this.observer !== undefined;\n\t}\n\n\tpublic start(): Observable<MutationProcessorEvent> {\n\t\tthis.runningProcesses = new BackgroundProcessManager();\n\n\t\tconst observable = new Observable<MutationProcessorEvent>(observer => {\n\t\t\tthis.observer = observer;\n\n\t\t\ttry {\n\t\t\t\tthis.resume();\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('mutations processor start error', error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\treturn this.runningProcesses.addCleaner(async () => {\n\t\t\t\t// The observer has unsubscribed and/or `stop()` has been called.\n\t\t\t\tthis.removeObserver();\n\t\t\t\tthis.pause();\n\t\t\t});\n\t\t});\n\n\t\treturn observable;\n\t}\n\n\tpublic async stop() {\n\t\tthis.removeObserver();\n\t\tawait this.runningProcesses.close();\n\t\tawait this.runningProcesses.open();\n\t}\n\n\tpublic removeObserver() {\n\t\tthis.observer?.complete?.();\n\t\tthis.observer = undefined;\n\t}\n\n\tpublic async resume(): Promise<void> {\n\t\tawait (this.runningProcesses.isOpen &&\n\t\t\tthis.runningProcesses.add(async onTerminate => {\n\t\t\t\tif (\n\t\t\t\t\tthis.processing ||\n\t\t\t\t\t!this.isReady() ||\n\t\t\t\t\t!this.runningProcesses.isOpen\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.processing = true;\n\t\t\t\tlet head: MutationEvent;\n\t\t\t\tconst namespaceName = USER;\n\n\t\t\t\t// start to drain outbox\n\t\t\t\twhile (\n\t\t\t\t\tthis.processing &&\n\t\t\t\t\tthis.runningProcesses.isOpen &&\n\t\t\t\t\t(head = await this.outbox.peek(this.storage)) !== undefined\n\t\t\t\t) {\n\t\t\t\t\tconst { model, operation, data, condition } = head;\n\t\t\t\t\tconst modelConstructor = this.userClasses[\n\t\t\t\t\t\tmodel\n\t\t\t\t\t] as PersistentModelConstructor<MutationEvent>;\n\t\t\t\t\tlet result: GraphQLResult<Record<string, PersistentModel>> =\n\t\t\t\t\t\tundefined!;\n\t\t\t\t\tlet opName: string = undefined!;\n\t\t\t\t\tlet modelDefinition: SchemaModel = undefined!;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst modelAuthModes = await getModelAuthModes({\n\t\t\t\t\t\t\tauthModeStrategy: this.authModeStrategy,\n\t\t\t\t\t\t\tdefaultAuthMode:\n\t\t\t\t\t\t\t\tthis.amplifyConfig.aws_appsync_authenticationType,\n\t\t\t\t\t\t\tmodelName: model,\n\t\t\t\t\t\t\tschema: this.schema,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst operationAuthModes = modelAuthModes[operation.toUpperCase()];\n\n\t\t\t\t\t\tlet authModeAttempts = 0;\n\t\t\t\t\t\tconst authModeRetry = async () => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t`Attempting mutation with authMode: ${operationAuthModes[authModeAttempts]}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst response = await this.jitteredRetry(\n\t\t\t\t\t\t\t\t\tnamespaceName,\n\t\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\t\toperation,\n\t\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\t\tcondition,\n\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\tthis.MutationEvent,\n\t\t\t\t\t\t\t\t\thead,\n\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts],\n\t\t\t\t\t\t\t\t\tonTerminate\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t`Mutation sent successfully with authMode: ${operationAuthModes[authModeAttempts]}`\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\treturn response;\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\tauthModeAttempts++;\n\t\t\t\t\t\t\t\tif (authModeAttempts >= operationAuthModes.length) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t\t`Mutation failed with authMode: ${\n\t\t\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts - 1]\n\t\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tawait this.errorHandler({\n\t\t\t\t\t\t\t\t\t\t\trecoverySuggestion:\n\t\t\t\t\t\t\t\t\t\t\t\t'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n\t\t\t\t\t\t\t\t\t\t\tlocalModel: null!,\n\t\t\t\t\t\t\t\t\t\t\tmessage: error.message,\n\t\t\t\t\t\t\t\t\t\t\tmodel: modelConstructor.name,\n\t\t\t\t\t\t\t\t\t\t\toperation: opName,\n\t\t\t\t\t\t\t\t\t\t\terrorType: getMutationErrorType(error),\n\t\t\t\t\t\t\t\t\t\t\tprocess: ProcessName.sync,\n\t\t\t\t\t\t\t\t\t\t\tremoteModel: null!,\n\t\t\t\t\t\t\t\t\t\t\tcause: error,\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t\tlogger.error('Mutation error handler failed with:', e);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t`Mutation failed with authMode: ${\n\t\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts - 1]\n\t\t\t\t\t\t\t\t\t}. Retrying with authMode: ${\n\t\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts]\n\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn await authModeRetry();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t[result, opName, modelDefinition] = await authModeRetry();\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\terror.message === 'Offline' ||\n\t\t\t\t\t\t\terror.message === 'RetryMutation'\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tlogger.debug('done retrying');\n\t\t\t\t\t\tawait this.storage.runExclusive(async storage => {\n\t\t\t\t\t\t\tawait this.outbox.dequeue(storage);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst record = result.data![opName!];\n\t\t\t\t\tlet hasMore = false;\n\n\t\t\t\t\tawait this.storage.runExclusive(async storage => {\n\t\t\t\t\t\t// using runExclusive to prevent possible race condition\n\t\t\t\t\t\t// when another record gets enqueued between dequeue and peek\n\t\t\t\t\t\tawait this.outbox.dequeue(storage, record, operation);\n\t\t\t\t\t\thasMore = (await this.outbox.peek(storage)) !== undefined;\n\t\t\t\t\t});\n\n\t\t\t\t\tthis.observer?.next?.({\n\t\t\t\t\t\toperation,\n\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\tmodel: record,\n\t\t\t\t\t\thasMore,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// pauses itself\n\t\t\t\tthis.pause();\n\t\t\t}, 'mutation resume loop'));\n\t}\n\n\tprivate async jitteredRetry(\n\t\tnamespaceName: string,\n\t\tmodel: string,\n\t\toperation: TransformerMutationType,\n\t\tdata: string,\n\t\tcondition: string,\n\t\tmodelConstructor: PersistentModelConstructor<PersistentModel>,\n\t\tMutationEvent: PersistentModelConstructor<MutationEvent>,\n\t\tmutationEvent: MutationEvent,\n\t\tauthMode: GRAPHQL_AUTH_MODE,\n\t\tonTerminate: Promise<void>\n\t): Promise<\n\t\t[GraphQLResult<Record<string, PersistentModel>>, string, SchemaModel]\n\t> {\n\t\treturn await retry(\n\t\t\tasync (\n\t\t\t\tmodel: string,\n\t\t\t\toperation: TransformerMutationType,\n\t\t\t\tdata: string,\n\t\t\t\tcondition: string,\n\t\t\t\tmodelConstructor: PersistentModelConstructor<PersistentModel>,\n\t\t\t\tMutationEvent: PersistentModelConstructor<MutationEvent>,\n\t\t\t\tmutationEvent: MutationEvent\n\t\t\t) => {\n\t\t\t\tconst [query, variables, graphQLCondition, opName, modelDefinition] =\n\t\t\t\t\tthis.createQueryVariables(\n\t\t\t\t\t\tnamespaceName,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\toperation,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tcondition\n\t\t\t\t\t);\n\n\t\t\t\tconst authToken = await getTokenForCustomAuth(\n\t\t\t\t\tauthMode,\n\t\t\t\t\tthis.amplifyConfig\n\t\t\t\t);\n\n\t\t\t\tconst tryWith = {\n\t\t\t\t\tquery,\n\t\t\t\t\tvariables,\n\t\t\t\t\tauthMode,\n\t\t\t\t\tauthToken,\n\t\t\t\t};\n\t\t\t\tlet attempt = 0;\n\n\t\t\t\tconst opType = this.opTypeFromTransformerOperation(operation);\n\n\t\t\t\tconst customUserAgentDetails: CustomUserAgentDetails = {\n\t\t\t\t\tcategory: Category.DataStore,\n\t\t\t\t\taction: DataStoreAction.GraphQl,\n\t\t\t\t};\n\n\t\t\t\tdo {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst result = <GraphQLResult<Record<string, PersistentModel>>>(\n\t\t\t\t\t\t\tawait this.amplifyContext.InternalAPI.graphql(\n\t\t\t\t\t\t\t\ttryWith,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tcustomUserAgentDetails\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Use `as any` because TypeScript doesn't seem to like passing tuples\n\t\t\t\t\t\t// through generic params.\n\t\t\t\t\t\treturn [result, opName, modelDefinition] as any;\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tif (err.errors && err.errors.length > 0) {\n\t\t\t\t\t\t\tconst [error] = err.errors;\n\t\t\t\t\t\t\tconst { originalError: { code = null } = {} } = error;\n\n\t\t\t\t\t\t\tif (error.errorType === 'Unauthorized') {\n\t\t\t\t\t\t\t\tthrow new NonRetryableError('Unauthorized');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\terror.message === 'Network Error' ||\n\t\t\t\t\t\t\t\tcode === 'ECONNABORTED' // refers to axios timeout error caused by device's bad network condition\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tif (!this.processing) {\n\t\t\t\t\t\t\t\t\tthrow new NonRetryableError('Offline');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// TODO: Check errors on different env (react-native or other browsers)\n\t\t\t\t\t\t\t\tthrow new Error('Network Error');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (error.errorType === 'ConflictUnhandled') {\n\t\t\t\t\t\t\t\t// TODO: add on ConflictConditionalCheck error query last from server\n\t\t\t\t\t\t\t\tattempt++;\n\t\t\t\t\t\t\t\tlet retryWith: PersistentModel | typeof DISCARD;\n\n\t\t\t\t\t\t\t\tif (attempt > MAX_ATTEMPTS) {\n\t\t\t\t\t\t\t\t\tretryWith = DISCARD;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tretryWith = await this.conflictHandler!({\n\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\tlocalModel: this.modelInstanceCreator(\n\t\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\tvariables.input\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\tremoteModel: this.modelInstanceCreator(\n\t\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\terror.data\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\toperation: opType,\n\t\t\t\t\t\t\t\t\t\t\tattempts: attempt,\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\tlogger.warn('conflict trycatch', err);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (retryWith === DISCARD) {\n\t\t\t\t\t\t\t\t\t// Query latest from server and notify merger\n\n\t\t\t\t\t\t\t\t\tconst [[, opName, query]] = buildGraphQLOperation(\n\t\t\t\t\t\t\t\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t\t\t'GET'\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst authToken = await getTokenForCustomAuth(\n\t\t\t\t\t\t\t\t\t\tauthMode,\n\t\t\t\t\t\t\t\t\t\tthis.amplifyConfig\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst serverData = <\n\t\t\t\t\t\t\t\t\t\tGraphQLResult<Record<string, PersistentModel>>\n\t\t\t\t\t\t\t\t\t>await this.amplifyContext.InternalAPI.graphql(\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\t\t\t\tvariables: { id: variables.input.id },\n\t\t\t\t\t\t\t\t\t\t\tauthMode,\n\t\t\t\t\t\t\t\t\t\t\tauthToken,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\tcustomUserAgentDetails\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t// onTerminate cancel graphql()\n\n\t\t\t\t\t\t\t\t\treturn [serverData, opName, modelDefinition];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst namespace = this.schema.namespaces[namespaceName];\n\n\t\t\t\t\t\t\t\t// convert retry with to tryWith\n\t\t\t\t\t\t\t\tconst updatedMutation =\n\t\t\t\t\t\t\t\t\tcreateMutationInstanceFromModelOperation(\n\t\t\t\t\t\t\t\t\t\tnamespace.relationships!,\n\t\t\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t\t\topType,\n\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\tretryWith,\n\t\t\t\t\t\t\t\t\t\tgraphQLCondition,\n\t\t\t\t\t\t\t\t\t\tMutationEvent,\n\t\t\t\t\t\t\t\t\t\tthis.modelInstanceCreator,\n\t\t\t\t\t\t\t\t\t\tmutationEvent.id\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tawait this.storage.save(updatedMutation);\n\n\t\t\t\t\t\t\t\tthrow new NonRetryableError('RetryMutation');\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tthis.errorHandler({\n\t\t\t\t\t\t\t\t\t\trecoverySuggestion:\n\t\t\t\t\t\t\t\t\t\t\t'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n\t\t\t\t\t\t\t\t\t\tlocalModel: variables.input,\n\t\t\t\t\t\t\t\t\t\tmessage: error.message,\n\t\t\t\t\t\t\t\t\t\toperation,\n\t\t\t\t\t\t\t\t\t\terrorType: getMutationErrorType(error),\n\t\t\t\t\t\t\t\t\t\terrorInfo: error.errorInfo,\n\t\t\t\t\t\t\t\t\t\tprocess: ProcessName.mutate,\n\t\t\t\t\t\t\t\t\t\tcause: error,\n\t\t\t\t\t\t\t\t\t\tremoteModel: error.data\n\t\t\t\t\t\t\t\t\t\t\t? this.modelInstanceCreator(modelConstructor, error.data)\n\t\t\t\t\t\t\t\t\t\t\t: null!,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\tlogger.warn('Mutation error handler failed with:', err);\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// Return empty tuple, dequeues the mutation\n\t\t\t\t\t\t\t\t\treturn error.data\n\t\t\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t\t\t{ data: { [opName]: error.data } },\n\t\t\t\t\t\t\t\t\t\t\t\topName,\n\t\t\t\t\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t\t\t  ]\n\t\t\t\t\t\t\t\t\t\t: [];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Catch-all for client-side errors that don't come back in the `GraphQLError` format.\n\t\t\t\t\t\t\t// These errors should not be retried.\n\t\t\t\t\t\t\tthrow new NonRetryableError(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (tryWith);\n\t\t\t},\n\t\t\t[\n\t\t\t\tmodel,\n\t\t\t\toperation,\n\t\t\t\tdata,\n\t\t\t\tcondition,\n\t\t\t\tmodelConstructor,\n\t\t\t\tMutationEvent,\n\t\t\t\tmutationEvent,\n\t\t\t],\n\t\t\tsafeJitteredBackoff,\n\t\t\tonTerminate\n\t\t);\n\t}\n\n\tprivate createQueryVariables(\n\t\tnamespaceName: string,\n\t\tmodel: string,\n\t\toperation: TransformerMutationType,\n\t\tdata: string,\n\t\tcondition: string\n\t): [string, Record<string, any>, GraphQLCondition, string, SchemaModel] {\n\t\tconst modelDefinition = this.schema.namespaces[namespaceName].models[model];\n\t\tconst { primaryKey } = this.schema.namespaces[namespaceName].keys![model];\n\n\t\tconst auth = modelDefinition.attributes?.find(a => a.type === 'auth');\n\t\tconst ownerFields: string[] = auth?.properties?.rules\n\t\t\t.map(rule => rule.ownerField)\n\t\t\t.filter(f => f) || ['owner'];\n\n\t\tconst queriesTuples = this.typeQuery.get(modelDefinition);\n\n\t\tconst [, opName, query] = queriesTuples!.find(\n\t\t\t([transformerMutationType]) => transformerMutationType === operation\n\t\t)!;\n\n\t\tconst { _version, ...parsedData } = <ModelInstanceMetadata>JSON.parse(data);\n\n\t\t// include all the fields that comprise a custom PK if one is specified\n\t\tconst deleteInput = {};\n\t\tif (primaryKey?.length) {\n\t\t\tfor (const pkField of primaryKey) {\n\t\t\t\tdeleteInput[pkField] = parsedData[pkField];\n\t\t\t}\n\t\t} else {\n\t\t\tdeleteInput[ID] = (<any>parsedData).id;\n\t\t}\n\n\t\tlet mutationInput;\n\n\t\tif (operation === TransformerMutationType.DELETE) {\n\t\t\t// For DELETE mutations, only the key(s) are included in the input\n\t\t\tmutationInput = <ModelInstanceMetadata>deleteInput;\n\t\t} else {\n\t\t\t// Otherwise, we construct the mutation input with the following logic\n\t\t\tmutationInput = {};\n\t\t\tconst modelFields = Object.values(modelDefinition.fields);\n\n\t\t\tfor (const { name, type, association, isReadOnly } of modelFields) {\n\t\t\t\t// omit readonly fields. cloud storage doesn't need them and won't take them!\n\t\t\t\tif (isReadOnly) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// omit owner fields if it's `null`. cloud storage doesn't allow it.\n\t\t\t\tif (ownerFields.includes(name) && parsedData[name] === null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// model fields should be stripped out from the input\n\t\t\t\tif (isModelFieldType(type)) {\n\t\t\t\t\t// except for belongs to relations - we need to replace them with the correct foreign key(s)\n\t\t\t\t\tif (\n\t\t\t\t\t\tisTargetNameAssociation(association) &&\n\t\t\t\t\t\tassociation.connectionType === 'BELONGS_TO'\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst targetNames: string[] | undefined =\n\t\t\t\t\t\t\textractTargetNamesFromSrc(association);\n\n\t\t\t\t\t\tif (targetNames) {\n\t\t\t\t\t\t\t// instead of including the connected model itself, we add its key(s) to the mutation input\n\t\t\t\t\t\t\tfor (const targetName of targetNames) {\n\t\t\t\t\t\t\t\tmutationInput[targetName] = parsedData[targetName];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// scalar fields / non-model types\n\n\t\t\t\tif (operation === TransformerMutationType.UPDATE) {\n\t\t\t\t\tif (!parsedData.hasOwnProperty(name)) {\n\t\t\t\t\t\t// for update mutations - strip out a field if it's unchanged\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// all other fields are added to the input object\n\t\t\t\tmutationInput[name] = parsedData[name];\n\t\t\t}\n\t\t}\n\n\t\t// Build mutation variables input object\n\t\tconst input: ModelInstanceMetadata = {\n\t\t\t...mutationInput,\n\t\t\t_version,\n\t\t};\n\n\t\tconst graphQLCondition = <GraphQLCondition>JSON.parse(condition);\n\n\t\tconst variables = {\n\t\t\tinput,\n\t\t\t...(operation === TransformerMutationType.CREATE\n\t\t\t\t? {}\n\t\t\t\t: {\n\t\t\t\t\t\tcondition:\n\t\t\t\t\t\t\tObject.keys(graphQLCondition).length > 0\n\t\t\t\t\t\t\t\t? graphQLCondition\n\t\t\t\t\t\t\t\t: null,\n\t\t\t\t  }),\n\t\t};\n\t\treturn [query, variables, graphQLCondition, opName, modelDefinition];\n\t}\n\n\tprivate opTypeFromTransformerOperation(\n\t\toperation: TransformerMutationType\n\t): OpType {\n\t\tswitch (operation) {\n\t\t\tcase TransformerMutationType.CREATE:\n\t\t\t\treturn OpType.INSERT;\n\t\t\tcase TransformerMutationType.DELETE:\n\t\t\t\treturn OpType.DELETE;\n\t\t\tcase TransformerMutationType.UPDATE:\n\t\t\t\treturn OpType.UPDATE;\n\t\t\tcase TransformerMutationType.GET: // Intentionally blank\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Invalid operation ${operation}`);\n\t\t}\n\n\t\t// because it makes TS happy ...\n\t\treturn undefined!;\n\t}\n\n\tpublic pause() {\n\t\tthis.processing = false;\n\t}\n}\n\nconst MAX_RETRY_DELAY_MS = 5 * 60 * 1000;\nconst originalJitteredBackoff = jitteredBackoff(MAX_RETRY_DELAY_MS);\n\n/**\n * @private\n * Internal use of Amplify only.\n *\n * Wraps the jittered backoff calculation to retry Network Errors indefinitely.\n * Backs off according to original jittered retry logic until the original retry\n * logic hits its max. After this occurs, if the error is a Network Error, we\n * ignore the attempt count and return MAX_RETRY_DELAY_MS to retry forever (until\n * the request succeeds).\n *\n * @param attempt ignored\n * @param _args ignored\n * @param error tested to see if `.message` is 'Network Error'\n * @returns number | false :\n */\nexport const safeJitteredBackoff: typeof originalJitteredBackoff = (\n\tattempt,\n\t_args,\n\terror\n) => {\n\tconst attemptResult = originalJitteredBackoff(attempt);\n\n\t// If this is the last attempt and it is a network error, we retry indefinitively every 5 minutes\n\tif (attemptResult === false && error?.message === 'Network Error') {\n\t\treturn MAX_RETRY_DELAY_MS;\n\t}\n\n\treturn attemptResult;\n};\n\nexport { MutationProcessor };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}