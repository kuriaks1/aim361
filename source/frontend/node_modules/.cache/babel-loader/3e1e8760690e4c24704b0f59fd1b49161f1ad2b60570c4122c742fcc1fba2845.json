{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __assign, __awaiter, __generator, __rest } from \"tslib\";\nimport { ConsoleLogger as Logger, Hub, StorageHelper } from '@aws-amplify/core';\nimport flatten from 'lodash/flatten';\nimport { addEventListener, notifyEventListeners } from '../common';\nimport { AWSPinpointProvider } from './Providers';\nimport { InAppMessageInteractionEvent } from './types';\nvar STORAGE_KEY_SUFFIX = '_inAppMessages';\nvar logger = new Logger('Notifications.InAppMessaging');\nvar InAppMessaging = /** @class */function () {\n  function InAppMessaging() {\n    var _this = this;\n    this.config = {};\n    this.listeningForAnalyticEvents = false;\n    this.pluggables = [];\n    this.storageSynced = false;\n    /**\n     * Configure InAppMessaging\n     * @param {Object} config - InAppMessaging configuration object\n     */\n    this.configure = function (_a) {\n      if (_a === void 0) {\n        _a = {};\n      }\n      var _b = _a.listenForAnalyticsEvents,\n        listenForAnalyticsEvents = _b === void 0 ? true : _b,\n        config = __rest(_a, [\"listenForAnalyticsEvents\"]);\n      _this.config = __assign(__assign({}, _this.config), config);\n      logger.debug('configure InAppMessaging', _this.config);\n      _this.pluggables.forEach(function (pluggable) {\n        pluggable.configure(_this.config[pluggable.getProviderName()]);\n      });\n      if (_this.pluggables.length === 0) {\n        _this.addPluggable(new AWSPinpointProvider());\n      }\n      if (listenForAnalyticsEvents && !_this.listeningForAnalyticEvents) {\n        Hub.listen('analytics', _this.analyticsListener);\n        _this.listeningForAnalyticEvents = true;\n      }\n      return _this.config;\n    };\n    /**\n     * Get a plugin from added plugins\n     * @param {string} providerName - the name of the plugin to get\n     */\n    this.getPluggable = function (providerName) {\n      var _a;\n      var pluggable = (_a = _this.pluggables.find(function (pluggable) {\n        return pluggable.getProviderName() === providerName;\n      })) !== null && _a !== void 0 ? _a : null;\n      if (!pluggable) {\n        logger.debug(\"No plugin found with name \" + providerName);\n      }\n      return pluggable;\n    };\n    /**\n     * Add plugin into InAppMessaging\n     * @param {InAppMessagingProvider} pluggable - an instance of the plugin\n     */\n    this.addPluggable = function (pluggable) {\n      if (pluggable && pluggable.getCategory() === 'Notifications' && pluggable.getSubCategory() === 'InAppMessaging') {\n        if (_this.getPluggable(pluggable.getProviderName())) {\n          throw new Error(\"Pluggable \" + pluggable.getProviderName() + \" has already been added.\");\n        }\n        _this.pluggables.push(pluggable);\n        pluggable.configure(_this.config[pluggable.getProviderName()]);\n      }\n    };\n    /**\n     * Remove a plugin from added plugins\n     * @param {string} providerName - the name of the plugin to remove\n     */\n    this.removePluggable = function (providerName) {\n      var index = _this.pluggables.findIndex(function (pluggable) {\n        return pluggable.getProviderName() === providerName;\n      });\n      if (index === -1) {\n        logger.debug(\"No plugin found with name \" + providerName);\n      } else {\n        _this.pluggables.splice(index, 1);\n      }\n    };\n    /**\n     * Get the map resources that are currently available through the provider\n     * @param {string} provider\n     * @returns - Array of available map resources\n     */\n    this.syncMessages = function () {\n      return Promise.all(_this.pluggables.map(function (pluggable) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var messages, key, err_1;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _a.trys.push([0, 3,, 4]);\n                return [4 /*yield*/, pluggable.getInAppMessages()];\n              case 1:\n                messages = _a.sent();\n                key = \"\" + pluggable.getProviderName() + STORAGE_KEY_SUFFIX;\n                return [4 /*yield*/, this.setMessages(key, messages)];\n              case 2:\n                _a.sent();\n                return [3 /*break*/, 4];\n              case 3:\n                err_1 = _a.sent();\n                logger.error('Failed to sync messages', err_1);\n                throw err_1;\n              case 4:\n                return [2 /*return*/];\n            }\n          });\n        });\n      }));\n    };\n\n    this.clearMessages = function () {\n      return Promise.all(_this.pluggables.map(function (pluggable) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var key;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                key = \"\" + pluggable.getProviderName() + STORAGE_KEY_SUFFIX;\n                return [4 /*yield*/, this.removeMessages(key)];\n              case 1:\n                _a.sent();\n                return [2 /*return*/];\n            }\n          });\n        });\n      }));\n    };\n\n    this.dispatchEvent = function (event) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var messages, flattenedMessages;\n        var _this = this;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4 /*yield*/, Promise.all(this.pluggables.map(function (pluggable) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var key, messages;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        key = \"\" + pluggable.getProviderName() + STORAGE_KEY_SUFFIX;\n                        return [4 /*yield*/, this.getMessages(key)];\n                      case 1:\n                        messages = _a.sent();\n                        return [2 /*return*/, pluggable.processInAppMessages(messages, event)];\n                    }\n                  });\n                });\n              }))];\n            case 1:\n              messages = _a.sent();\n              flattenedMessages = flatten(messages);\n              if (flattenedMessages.length) {\n                notifyEventListeners(InAppMessageInteractionEvent.MESSAGE_RECEIVED, this.conflictHandler(flattenedMessages));\n              }\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.identifyUser = function (userId, userInfo) {\n      return Promise.all(_this.pluggables.map(function (pluggable) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var err_2;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _a.trys.push([0, 2,, 3]);\n                return [4 /*yield*/, pluggable.identifyUser(userId, userInfo)];\n              case 1:\n                _a.sent();\n                return [3 /*break*/, 3];\n              case 2:\n                err_2 = _a.sent();\n                logger.error('Failed to identify user', err_2);\n                throw err_2;\n              case 3:\n                return [2 /*return*/];\n            }\n          });\n        });\n      }));\n    };\n\n    this.onMessageReceived = function (handler) {\n      return addEventListener(InAppMessageInteractionEvent.MESSAGE_RECEIVED, handler);\n    };\n    this.onMessageDisplayed = function (handler) {\n      return addEventListener(InAppMessageInteractionEvent.MESSAGE_DISPLAYED, handler);\n    };\n    this.onMessageDismissed = function (handler) {\n      return addEventListener(InAppMessageInteractionEvent.MESSAGE_DISMISSED, handler);\n    };\n    this.onMessageActionTaken = function (handler) {\n      return addEventListener(InAppMessageInteractionEvent.MESSAGE_ACTION_TAKEN, handler);\n    };\n    this.notifyMessageInteraction = function (message, type) {\n      notifyEventListeners(type, message);\n    };\n    this.setConflictHandler = function (handler) {\n      _this.conflictHandler = handler;\n    };\n    this.analyticsListener = function (_a) {\n      var payload = _a.payload;\n      var event = payload.event,\n        data = payload.data;\n      switch (event) {\n        case 'record':\n          {\n            _this.dispatchEvent(data);\n            break;\n          }\n        default:\n          break;\n      }\n    };\n    this.syncStorage = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var storage, err_3;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              storage = this.config.storage;\n              _a.label = 1;\n            case 1:\n              _a.trys.push([1, 4,, 5]);\n              if (!(typeof storage.sync === 'function')) return [3 /*break*/, 3];\n              return [4 /*yield*/, storage.sync()];\n            case 2:\n              _a.sent();\n              _a.label = 3;\n            case 3:\n              this.storageSynced = true;\n              return [3 /*break*/, 5];\n            case 4:\n              err_3 = _a.sent();\n              logger.error('Failed to sync storage', err_3);\n              return [3 /*break*/, 5];\n            case 5:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.getMessages = function (key) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var storage, storedMessages, err_4;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 3,, 4]);\n              if (!!this.storageSynced) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.syncStorage()];\n            case 1:\n              _a.sent();\n              _a.label = 2;\n            case 2:\n              storage = this.config.storage;\n              storedMessages = storage.getItem(key);\n              return [2 /*return*/, storedMessages ? JSON.parse(storedMessages) : []];\n            case 3:\n              err_4 = _a.sent();\n              logger.error('Failed to retrieve in-app messages from storage', err_4);\n              return [3 /*break*/, 4];\n            case 4:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.setMessages = function (key, messages) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var storage, err_5;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!messages) {\n                return [2 /*return*/];\n              }\n\n              _a.label = 1;\n            case 1:\n              _a.trys.push([1, 4,, 5]);\n              if (!!this.storageSynced) return [3 /*break*/, 3];\n              return [4 /*yield*/, this.syncStorage()];\n            case 2:\n              _a.sent();\n              _a.label = 3;\n            case 3:\n              storage = this.config.storage;\n              storage.setItem(key, JSON.stringify(messages));\n              return [3 /*break*/, 5];\n            case 4:\n              err_5 = _a.sent();\n              logger.error('Failed to store in-app messages', err_5);\n              return [3 /*break*/, 5];\n            case 5:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.removeMessages = function (key) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var storage, err_6;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 3,, 4]);\n              if (!!this.storageSynced) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.syncStorage()];\n            case 1:\n              _a.sent();\n              _a.label = 2;\n            case 2:\n              storage = this.config.storage;\n              storage.removeItem(key);\n              return [3 /*break*/, 4];\n            case 3:\n              err_6 = _a.sent();\n              logger.error('Failed to remove in-app messages from storage', err_6);\n              return [3 /*break*/, 4];\n            case 4:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.defaultConflictHandler = function (messages) {\n      // default behavior is to return the message closest to expiry\n      // this function assumes that messages processed by providers already filters out expired messages\n      var sorted = messages.sort(function (a, b) {\n        var _a, _b;\n        var endDateA = (_a = a.metadata) === null || _a === void 0 ? void 0 : _a.endDate;\n        var endDateB = (_b = b.metadata) === null || _b === void 0 ? void 0 : _b.endDate;\n        // if both message end dates are falsy or have the same date string, treat them as equal\n        if (endDateA === endDateB) {\n          return 0;\n        }\n        // if only message A has an end date, treat it as closer to expiry\n        if (endDateA && !endDateB) {\n          return -1;\n        }\n        // if only message B has an end date, treat it as closer to expiry\n        if (!endDateA && endDateB) {\n          return 1;\n        }\n        // otherwise, compare them\n        return new Date(endDateA) < new Date(endDateB) ? -1 : 1;\n      });\n      // always return the top sorted\n      return sorted[0];\n    };\n    this.config = {\n      storage: new StorageHelper().getStorage()\n    };\n    this.setConflictHandler(this.defaultConflictHandler);\n  }\n  /**\n   * Get the name of this module\n   * @returns {string} name of this module\n   */\n  InAppMessaging.prototype.getModuleName = function () {\n    return 'InAppMessaging';\n  };\n  return InAppMessaging;\n}();\nexport default InAppMessaging;","map":{"version":3,"mappings":"AAAA;AACA;;AAEA,SACCA,aAAa,IAAIC,MAAM,EAGvBC,GAAG,EACHC,aAAa,QACP,mBAAmB;AAC1B,OAAOC,OAAO,MAAM,gBAAgB;AAEpC,SACCC,gBAAgB,EAEhBC,oBAAoB,QACd,WAAW;AAElB,SAASC,mBAAmB,QAAQ,aAAa;AACjD,SAECC,4BAA4B,QAQtB,SAAS;AAEhB,IAAMC,kBAAkB,GAAG,gBAAgB;AAE3C,IAAMC,MAAM,GAAG,IAAIT,MAAM,CAAC,8BAA8B,CAAC;AAEzD;EAOC;IAAA;IANQ,WAAM,GAAwB,EAAE;IAEhC,+BAA0B,GAAG,KAAK;IAClC,eAAU,GAA6B,EAAE;IACzC,kBAAa,GAAG,KAAK;IAO7B;;;;IAIA,cAAS,GAAG,UAACU,EAGe;MAHf;QAAAA,OAGe;MAAA;MAF3B,oCAA+B;QAA/BC,oDAA+B;QAC/BC,iDAAS;MAETC,KAAI,CAACD,MAAM,yBAAQC,KAAI,CAACD,MAAM,GAAKA,MAAM,CAAE;MAE3CH,MAAM,CAACK,KAAK,CAAC,0BAA0B,EAAED,KAAI,CAACD,MAAM,CAAC;MAErDC,KAAI,CAACE,UAAU,CAACC,OAAO,CAAC,mBAAS;QAChCC,SAAS,CAACC,SAAS,CAACL,KAAI,CAACD,MAAM,CAACK,SAAS,CAACE,eAAe,EAAE,CAAC,CAAC;MAC9D,CAAC,CAAC;MAEF,IAAIN,KAAI,CAACE,UAAU,CAACK,MAAM,KAAK,CAAC,EAAE;QACjCP,KAAI,CAACQ,YAAY,CAAC,IAAIf,mBAAmB,EAAE,CAAC;;MAG7C,IAAIK,wBAAwB,IAAI,CAACE,KAAI,CAACS,0BAA0B,EAAE;QACjErB,GAAG,CAACsB,MAAM,CAAC,WAAW,EAAEV,KAAI,CAACW,iBAAiB,CAAC;QAC/CX,KAAI,CAACS,0BAA0B,GAAG,IAAI;;MAGvC,OAAOT,KAAI,CAACD,MAAM;IACnB,CAAC;IAUD;;;;IAIA,iBAAY,GAAG,UAACa,YAAoB;;MACnC,IAAMR,SAAS,SACdJ,KAAI,CAACE,UAAU,CAACW,IAAI,CACnB,mBAAS;QAAI,gBAAS,CAACP,eAAe,EAAE,KAAKM,YAAY;MAA5C,CAA4C,CACzD,mCAAI,IAAI;MAEV,IAAI,CAACR,SAAS,EAAE;QACfR,MAAM,CAACK,KAAK,CAAC,+BAA6BW,YAAc,CAAC;;MAG1D,OAAOR,SAAS;IACjB,CAAC;IAED;;;;IAIA,iBAAY,GAAG,UAACA,SAAiC;MAChD,IACCA,SAAS,IACTA,SAAS,CAACU,WAAW,EAAE,KAAK,eAAe,IAC3CV,SAAS,CAACW,cAAc,EAAE,KAAK,gBAAgB,EAC9C;QACD,IAAIf,KAAI,CAACgB,YAAY,CAACZ,SAAS,CAACE,eAAe,EAAE,CAAC,EAAE;UACnD,MAAM,IAAIW,KAAK,CACd,eAAab,SAAS,CAACE,eAAe,EAAE,6BAA0B,CAClE;;QAEFN,KAAI,CAACE,UAAU,CAACgB,IAAI,CAACd,SAAS,CAAC;QAC/BA,SAAS,CAACC,SAAS,CAACL,KAAI,CAACD,MAAM,CAACK,SAAS,CAACE,eAAe,EAAE,CAAC,CAAC;;IAE/D,CAAC;IAED;;;;IAIA,oBAAe,GAAG,UAACM,YAAoB;MACtC,IAAMO,KAAK,GAAGnB,KAAI,CAACE,UAAU,CAACkB,SAAS,CACtC,mBAAS;QAAI,gBAAS,CAACd,eAAe,EAAE,KAAKM,YAAY;MAA5C,CAA4C,CACzD;MACD,IAAIO,KAAK,KAAK,CAAC,CAAC,EAAE;QACjBvB,MAAM,CAACK,KAAK,CAAC,+BAA6BW,YAAc,CAAC;OACzD,MAAM;QACNZ,KAAI,CAACE,UAAU,CAACmB,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;;IAElC,CAAC;IAED;;;;;IAKA,iBAAY,GAAG;MACd,cAAO,CAACG,GAAG,CACVtB,KAAI,CAACE,UAAU,CAACqB,GAAG,CAAC,UAAMnB,SAAS;QAAA;;;;;;gBAEhB,qBAAMA,SAAS,CAACoB,gBAAgB,EAAE;;gBAA7CC,QAAQ,GAAG5B,SAAkC;gBAC7C6B,GAAG,GAAG,KAAGtB,SAAS,CAACE,eAAe,EAAE,GAAGX,kBAAoB;gBACjE,qBAAM,IAAI,CAACgC,WAAW,CAACD,GAAG,EAAED,QAAQ,CAAC;;gBAArC5B,SAAqC;;;;gBAErCD,MAAM,CAACgC,KAAK,CAAC,yBAAyB,EAAEC,KAAG,CAAC;gBAC5C,MAAMA,KAAG;;;;;;OAEV,CAAC,CACF;IAXD,CAWC;;IAEF,kBAAa,GAAG;MACf,cAAO,CAACP,GAAG,CACVtB,KAAI,CAACE,UAAU,CAACqB,GAAG,CAAC,UAAMnB,SAAS;QAAA;;;;;gBAC5BsB,GAAG,GAAG,KAAGtB,SAAS,CAACE,eAAe,EAAE,GAAGX,kBAAoB;gBACjE,qBAAM,IAAI,CAACmC,cAAc,CAACJ,GAAG,CAAC;;gBAA9B7B,SAA8B;;;;;OAC9B,CAAC,CACF;IALD,CAKC;;IAEF,kBAAa,GAAG,UAAOkC,KAA0B;MAAA;;;;;;cACb,qBAAMC,OAAO,CAACV,GAAG,CACnD,IAAI,CAACpB,UAAU,CAACqB,GAAG,CAAC,UAAMnB,SAAS;gBAAA;;;;;wBAC5BsB,GAAG,GAAG,KAAGtB,SAAS,CAACE,eAAe,EAAE,GAAGX,kBAAoB;wBAChD,qBAAM,IAAI,CAACsC,WAAW,CAACP,GAAG,CAAC;;wBAAtCD,QAAQ,GAAG5B,SAA2B;wBAC5C,sBAAOO,SAAS,CAAC8B,oBAAoB,CAACT,QAAQ,EAAEM,KAAK,CAAC;;;;eACtD,CAAC,CACF;;cANKN,QAAQ,GAAqB5B,SAMlC;cAEKsC,iBAAiB,GAAG7C,OAAO,CAACmC,QAAQ,CAAC;cAE3C,IAAIU,iBAAiB,CAAC5B,MAAM,EAAE;gBAC7Bf,oBAAoB,CACnBE,4BAA4B,CAAC0C,gBAAgB,EAC7C,IAAI,CAACC,eAAe,CAACF,iBAAiB,CAAC,CACvC;;;;;;KAEF;;IAED,iBAAY,GAAG,UAACG,MAAc,EAAEC,QAAkB;MACjD,cAAO,CAACjB,GAAG,CACVtB,KAAI,CAACE,UAAU,CAACqB,GAAG,CAAC,UAAMnB,SAAS;QAAA;;;;;;gBAEjC,qBAAMA,SAAS,CAACoC,YAAY,CAACF,MAAM,EAAEC,QAAQ,CAAC;;gBAA9C1C,SAA8C;;;;gBAE9CD,MAAM,CAACgC,KAAK,CAAC,yBAAyB,EAAEa,KAAG,CAAC;gBAC5C,MAAMA,KAAG;;;;;;OAEV,CAAC,CACF;IATD,CASC;;IAEF,sBAAiB,GAAG,UACnBC,OAAyC;MAEzC,uBAAgB,CAAChD,4BAA4B,CAAC0C,gBAAgB,EAAEM,OAAO,CAAC;IAAxE,CAAwE;IAEzE,uBAAkB,GAAG,UACpBA,OAAyC;MAEzC,uBAAgB,CAAChD,4BAA4B,CAACiD,iBAAiB,EAAED,OAAO,CAAC;IAAzE,CAAyE;IAE1E,uBAAkB,GAAG,UACpBA,OAAyC;MAEzC,uBAAgB,CAAChD,4BAA4B,CAACkD,iBAAiB,EAAEF,OAAO,CAAC;IAAzE,CAAyE;IAE1E,yBAAoB,GAAG,UACtBA,OAAyC;MAEzC,uBAAgB,CACfhD,4BAA4B,CAACmD,oBAAoB,EACjDH,OAAO,CACP;IAHD,CAGC;IAEF,6BAAwB,GAAG,UAC1BI,OAAqB,EACrBC,IAAkC;MAElCvD,oBAAoB,CAACuD,IAAI,EAAED,OAAO,CAAC;IACpC,CAAC;IAED,uBAAkB,GAAG,UAACJ,OAAoC;MACzD1C,KAAI,CAACqC,eAAe,GAAGK,OAAO;IAC/B,CAAC;IAEO,sBAAiB,GAAgB,UAAC7C,EAAuB;UAArBmD,oBAAO;MAC1C,yBAAK;QAAEC,mBAAI;MACnB,QAAQlB,KAAK;QACZ,KAAK,QAAQ;UAAE;YACd/B,KAAI,CAACkD,aAAa,CAACD,IAAI,CAAC;YACxB;;QAED;UACC;;IAEH,CAAC;IAEO,gBAAW,GAAG;MAAA;;;;;cACbE,OAAO,GAAK,IAAI,CAACpD,MAAM,QAAhB;;;;oBAGV,OAAOoD,OAAO,CAACC,IAAI,KAAK,UAAU,GAAlC;cACH,qBAAMD,OAAO,CAACC,IAAI,EAAE;;cAApBvD,SAAoB;;;cAErB,IAAI,CAACwD,aAAa,GAAG,IAAI;;;;cAEzBzD,MAAM,CAACgC,KAAK,CAAC,wBAAwB,EAAE0B,KAAG,CAAC;;;;;;;KAE5C;;IAEO,gBAAW,GAAG,UAAO5B,GAAW;MAAA;;;;;;mBAElC,CAAC,IAAI,CAAC2B,aAAa,EAAnB;cACH,qBAAM,IAAI,CAACE,WAAW,EAAE;;cAAxB1D,SAAwB;;;cAEjBsD,OAAO,GAAK,IAAI,CAACpD,MAAM,QAAhB;cACTyD,cAAc,GAAGL,OAAO,CAACM,OAAO,CAAC/B,GAAG,CAAC;cAC3C,sBAAO8B,cAAc,GAAGE,IAAI,CAACC,KAAK,CAACH,cAAc,CAAC,GAAG,EAAE;;;cAEvD5D,MAAM,CAACgC,KAAK,CAAC,iDAAiD,EAAEgC,KAAG,CAAC;;;;;;;KAErE;;IAEO,gBAAW,GAAG,UACrBlC,GAAW,EACXD,QAAwB;MAAA;;;;;cAExB,IAAI,CAACA,QAAQ,EAAE;gBACd;;;;;;mBAII,CAAC,IAAI,CAAC4B,aAAa,EAAnB;cACH,qBAAM,IAAI,CAACE,WAAW,EAAE;;cAAxB1D,SAAwB;;;cAEjBsD,OAAO,GAAK,IAAI,CAACpD,MAAM,QAAhB;cACfoD,OAAO,CAACU,OAAO,CAACnC,GAAG,EAAEgC,IAAI,CAACI,SAAS,CAACrC,QAAQ,CAAC,CAAC;;;;cAE9C7B,MAAM,CAACgC,KAAK,CAAC,iCAAiC,EAAEmC,KAAG,CAAC;;;;;;;KAErD;;IAEO,mBAAc,GAAG,UAAOrC,GAAW;MAAA;;;;;;mBAErC,CAAC,IAAI,CAAC2B,aAAa,EAAnB;cACH,qBAAM,IAAI,CAACE,WAAW,EAAE;;cAAxB1D,SAAwB;;;cAEjBsD,OAAO,GAAK,IAAI,CAACpD,MAAM,QAAhB;cACfoD,OAAO,CAACa,UAAU,CAACtC,GAAG,CAAC;;;;cAEvB9B,MAAM,CAACgC,KAAK,CAAC,+CAA+C,EAAEqC,KAAG,CAAC;;;;;;;KAEnE;;IAEO,2BAAsB,GAAG,UAACxC,QAAwB;MACzD;MACA;MACA,IAAMyC,MAAM,GAAGzC,QAAQ,CAAC0C,IAAI,CAAC,UAACC,CAAC,EAAEC,CAAC;;QACjC,IAAMC,QAAQ,SAAGF,CAAC,CAACG,QAAQ,0CAAEC,OAAO;QACpC,IAAMC,QAAQ,SAAGJ,CAAC,CAACE,QAAQ,0CAAEC,OAAO;QACpC;QACA,IAAIF,QAAQ,KAAKG,QAAQ,EAAE;UAC1B,OAAO,CAAC;;QAET;QACA,IAAIH,QAAQ,IAAI,CAACG,QAAQ,EAAE;UAC1B,OAAO,CAAC,CAAC;;QAEV;QACA,IAAI,CAACH,QAAQ,IAAIG,QAAQ,EAAE;UAC1B,OAAO,CAAC;;QAET;QACA,OAAO,IAAIC,IAAI,CAACJ,QAAQ,CAAC,GAAG,IAAII,IAAI,CAACD,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;MACxD,CAAC,CAAC;MACF;MACA,OAAOP,MAAM,CAAC,CAAC,CAAC;IACjB,CAAC;IApRA,IAAI,CAACnE,MAAM,GAAG;MAAEoD,OAAO,EAAE,IAAI9D,aAAa,EAAE,CAACsF,UAAU;IAAE,CAAE;IAC3D,IAAI,CAACC,kBAAkB,CAAC,IAAI,CAACC,sBAAsB,CAAC;EACrD;EA8BA;;;;EAIAC,sCAAa,GAAb;IACC,OAAO,gBAAgB;EACxB,CAAC;EA+OF,qBAAC;AAAD,CAAC,CA7RD","names":["ConsoleLogger","Logger","Hub","StorageHelper","flatten","addEventListener","notifyEventListeners","AWSPinpointProvider","InAppMessageInteractionEvent","STORAGE_KEY_SUFFIX","logger","_a","listenForAnalyticsEvents","config","_this","debug","pluggables","forEach","pluggable","configure","getProviderName","length","addPluggable","listeningForAnalyticEvents","listen","analyticsListener","providerName","find","getCategory","getSubCategory","getPluggable","Error","push","index","findIndex","splice","all","map","getInAppMessages","messages","key","setMessages","error","err_1","removeMessages","event","Promise","getMessages","processInAppMessages","flattenedMessages","MESSAGE_RECEIVED","conflictHandler","userId","userInfo","identifyUser","err_2","handler","MESSAGE_DISPLAYED","MESSAGE_DISMISSED","MESSAGE_ACTION_TAKEN","message","type","payload","data","dispatchEvent","storage","sync","storageSynced","err_3","syncStorage","storedMessages","getItem","JSON","parse","err_4","setItem","stringify","err_5","removeItem","err_6","sorted","sort","a","b","endDateA","metadata","endDate","endDateB","Date","getStorage","setConflictHandler","defaultConflictHandler","InAppMessaging"],"sources":["/Workshop/product-metadata/guidance-for-generating-product-descriptions-with-bedrock/source/frontend/node_modules/@aws-amplify/notifications/src/InAppMessaging/InAppMessaging.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tConsoleLogger as Logger,\n\tHubCallback,\n\tHubCapsule,\n\tHub,\n\tStorageHelper,\n} from '@aws-amplify/core';\nimport flatten from 'lodash/flatten';\n\nimport {\n\taddEventListener,\n\tEventListener,\n\tnotifyEventListeners,\n} from '../common';\nimport { UserInfo } from '../types';\nimport { AWSPinpointProvider } from './Providers';\nimport {\n\tInAppMessage,\n\tInAppMessageInteractionEvent,\n\tInAppMessagingInterface,\n\tInAppMessagingConfig,\n\tInAppMessageConflictHandler,\n\tInAppMessagingEvent,\n\tInAppMessagingProvider,\n\tNotificationsSubCategory,\n\tOnMessageInteractionEventHandler,\n} from './types';\n\nconst STORAGE_KEY_SUFFIX = '_inAppMessages';\n\nconst logger = new Logger('Notifications.InAppMessaging');\n\nexport default class InAppMessaging implements InAppMessagingInterface {\n\tprivate config: Record<string, any> = {};\n\tprivate conflictHandler: InAppMessageConflictHandler;\n\tprivate listeningForAnalyticEvents = false;\n\tprivate pluggables: InAppMessagingProvider[] = [];\n\tprivate storageSynced = false;\n\n\tconstructor() {\n\t\tthis.config = { storage: new StorageHelper().getStorage() };\n\t\tthis.setConflictHandler(this.defaultConflictHandler);\n\t}\n\n\t/**\n\t * Configure InAppMessaging\n\t * @param {Object} config - InAppMessaging configuration object\n\t */\n\tconfigure = ({\n\t\tlistenForAnalyticsEvents = true,\n\t\t...config\n\t}: InAppMessagingConfig = {}): InAppMessagingConfig => {\n\t\tthis.config = { ...this.config, ...config };\n\n\t\tlogger.debug('configure InAppMessaging', this.config);\n\n\t\tthis.pluggables.forEach(pluggable => {\n\t\t\tpluggable.configure(this.config[pluggable.getProviderName()]);\n\t\t});\n\n\t\tif (this.pluggables.length === 0) {\n\t\t\tthis.addPluggable(new AWSPinpointProvider());\n\t\t}\n\n\t\tif (listenForAnalyticsEvents && !this.listeningForAnalyticEvents) {\n\t\t\tHub.listen('analytics', this.analyticsListener);\n\t\t\tthis.listeningForAnalyticEvents = true;\n\t\t}\n\n\t\treturn this.config;\n\t};\n\n\t/**\n\t * Get the name of this module\n\t * @returns {string} name of this module\n\t */\n\tgetModuleName(): NotificationsSubCategory {\n\t\treturn 'InAppMessaging';\n\t}\n\n\t/**\n\t * Get a plugin from added plugins\n\t * @param {string} providerName - the name of the plugin to get\n\t */\n\tgetPluggable = (providerName: string): InAppMessagingProvider => {\n\t\tconst pluggable =\n\t\t\tthis.pluggables.find(\n\t\t\t\tpluggable => pluggable.getProviderName() === providerName\n\t\t\t) ?? null;\n\n\t\tif (!pluggable) {\n\t\t\tlogger.debug(`No plugin found with name ${providerName}`);\n\t\t}\n\n\t\treturn pluggable;\n\t};\n\n\t/**\n\t * Add plugin into InAppMessaging\n\t * @param {InAppMessagingProvider} pluggable - an instance of the plugin\n\t */\n\taddPluggable = (pluggable: InAppMessagingProvider): void => {\n\t\tif (\n\t\t\tpluggable &&\n\t\t\tpluggable.getCategory() === 'Notifications' &&\n\t\t\tpluggable.getSubCategory() === 'InAppMessaging'\n\t\t) {\n\t\t\tif (this.getPluggable(pluggable.getProviderName())) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Pluggable ${pluggable.getProviderName()} has already been added.`\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.pluggables.push(pluggable);\n\t\t\tpluggable.configure(this.config[pluggable.getProviderName()]);\n\t\t}\n\t};\n\n\t/**\n\t * Remove a plugin from added plugins\n\t * @param {string} providerName - the name of the plugin to remove\n\t */\n\tremovePluggable = (providerName: string): void => {\n\t\tconst index = this.pluggables.findIndex(\n\t\t\tpluggable => pluggable.getProviderName() === providerName\n\t\t);\n\t\tif (index === -1) {\n\t\t\tlogger.debug(`No plugin found with name ${providerName}`);\n\t\t} else {\n\t\t\tthis.pluggables.splice(index, 1);\n\t\t}\n\t};\n\n\t/**\n\t * Get the map resources that are currently available through the provider\n\t * @param {string} provider\n\t * @returns - Array of available map resources\n\t */\n\tsyncMessages = (): Promise<void[]> =>\n\t\tPromise.all<void>(\n\t\t\tthis.pluggables.map(async pluggable => {\n\t\t\t\ttry {\n\t\t\t\t\tconst messages = await pluggable.getInAppMessages();\n\t\t\t\t\tconst key = `${pluggable.getProviderName()}${STORAGE_KEY_SUFFIX}`;\n\t\t\t\t\tawait this.setMessages(key, messages);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tlogger.error('Failed to sync messages', err);\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\tclearMessages = (): Promise<void[]> =>\n\t\tPromise.all<void>(\n\t\t\tthis.pluggables.map(async pluggable => {\n\t\t\t\tconst key = `${pluggable.getProviderName()}${STORAGE_KEY_SUFFIX}`;\n\t\t\t\tawait this.removeMessages(key);\n\t\t\t})\n\t\t);\n\n\tdispatchEvent = async (event: InAppMessagingEvent): Promise<void> => {\n\t\tconst messages: InAppMessage[][] = await Promise.all<InAppMessage[]>(\n\t\t\tthis.pluggables.map(async pluggable => {\n\t\t\t\tconst key = `${pluggable.getProviderName()}${STORAGE_KEY_SUFFIX}`;\n\t\t\t\tconst messages = await this.getMessages(key);\n\t\t\t\treturn pluggable.processInAppMessages(messages, event);\n\t\t\t})\n\t\t);\n\n\t\tconst flattenedMessages = flatten(messages);\n\n\t\tif (flattenedMessages.length) {\n\t\t\tnotifyEventListeners(\n\t\t\t\tInAppMessageInteractionEvent.MESSAGE_RECEIVED,\n\t\t\t\tthis.conflictHandler(flattenedMessages)\n\t\t\t);\n\t\t}\n\t};\n\n\tidentifyUser = (userId: string, userInfo: UserInfo): Promise<void[]> =>\n\t\tPromise.all<void>(\n\t\t\tthis.pluggables.map(async pluggable => {\n\t\t\t\ttry {\n\t\t\t\t\tawait pluggable.identifyUser(userId, userInfo);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tlogger.error('Failed to identify user', err);\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\tonMessageReceived = (\n\t\thandler: OnMessageInteractionEventHandler\n\t): EventListener<OnMessageInteractionEventHandler> =>\n\t\taddEventListener(InAppMessageInteractionEvent.MESSAGE_RECEIVED, handler);\n\n\tonMessageDisplayed = (\n\t\thandler: OnMessageInteractionEventHandler\n\t): EventListener<OnMessageInteractionEventHandler> =>\n\t\taddEventListener(InAppMessageInteractionEvent.MESSAGE_DISPLAYED, handler);\n\n\tonMessageDismissed = (\n\t\thandler: OnMessageInteractionEventHandler\n\t): EventListener<OnMessageInteractionEventHandler> =>\n\t\taddEventListener(InAppMessageInteractionEvent.MESSAGE_DISMISSED, handler);\n\n\tonMessageActionTaken = (\n\t\thandler: OnMessageInteractionEventHandler\n\t): EventListener<OnMessageInteractionEventHandler> =>\n\t\taddEventListener(\n\t\t\tInAppMessageInteractionEvent.MESSAGE_ACTION_TAKEN,\n\t\t\thandler\n\t\t);\n\n\tnotifyMessageInteraction = (\n\t\tmessage: InAppMessage,\n\t\ttype: InAppMessageInteractionEvent\n\t): void => {\n\t\tnotifyEventListeners(type, message);\n\t};\n\n\tsetConflictHandler = (handler: InAppMessageConflictHandler): void => {\n\t\tthis.conflictHandler = handler;\n\t};\n\n\tprivate analyticsListener: HubCallback = ({ payload }: HubCapsule) => {\n\t\tconst { event, data } = payload;\n\t\tswitch (event) {\n\t\t\tcase 'record': {\n\t\t\t\tthis.dispatchEvent(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\tprivate syncStorage = async (): Promise<void> => {\n\t\tconst { storage } = this.config;\n\t\ttry {\n\t\t\t// Only run sync() if it's available (i.e. React Native)\n\t\t\tif (typeof storage.sync === 'function') {\n\t\t\t\tawait storage.sync();\n\t\t\t}\n\t\t\tthis.storageSynced = true;\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to sync storage', err);\n\t\t}\n\t};\n\n\tprivate getMessages = async (key: string): Promise<any> => {\n\t\ttry {\n\t\t\tif (!this.storageSynced) {\n\t\t\t\tawait this.syncStorage();\n\t\t\t}\n\t\t\tconst { storage } = this.config;\n\t\t\tconst storedMessages = storage.getItem(key);\n\t\t\treturn storedMessages ? JSON.parse(storedMessages) : [];\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to retrieve in-app messages from storage', err);\n\t\t}\n\t};\n\n\tprivate setMessages = async (\n\t\tkey: string,\n\t\tmessages: InAppMessage[]\n\t): Promise<void> => {\n\t\tif (!messages) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tif (!this.storageSynced) {\n\t\t\t\tawait this.syncStorage();\n\t\t\t}\n\t\t\tconst { storage } = this.config;\n\t\t\tstorage.setItem(key, JSON.stringify(messages));\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to store in-app messages', err);\n\t\t}\n\t};\n\n\tprivate removeMessages = async (key: string): Promise<void> => {\n\t\ttry {\n\t\t\tif (!this.storageSynced) {\n\t\t\t\tawait this.syncStorage();\n\t\t\t}\n\t\t\tconst { storage } = this.config;\n\t\t\tstorage.removeItem(key);\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to remove in-app messages from storage', err);\n\t\t}\n\t};\n\n\tprivate defaultConflictHandler = (messages: InAppMessage[]): InAppMessage => {\n\t\t// default behavior is to return the message closest to expiry\n\t\t// this function assumes that messages processed by providers already filters out expired messages\n\t\tconst sorted = messages.sort((a, b) => {\n\t\t\tconst endDateA = a.metadata?.endDate;\n\t\t\tconst endDateB = b.metadata?.endDate;\n\t\t\t// if both message end dates are falsy or have the same date string, treat them as equal\n\t\t\tif (endDateA === endDateB) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t// if only message A has an end date, treat it as closer to expiry\n\t\t\tif (endDateA && !endDateB) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// if only message B has an end date, treat it as closer to expiry\n\t\t\tif (!endDateA && endDateB) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t// otherwise, compare them\n\t\t\treturn new Date(endDateA) < new Date(endDateB) ? -1 : 1;\n\t\t});\n\t\t// always return the top sorted\n\t\treturn sorted[0];\n\t};\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}