{"ast":null,"code":"import { __asyncGenerator, __await, __generator } from \"tslib\";\nexport function getChunkedStream(source) {\n  var _a;\n  var currentMessageTotalLength = 0;\n  var currentMessagePendingLength = 0;\n  var currentMessage = null;\n  var messageLengthBuffer = null;\n  var allocateMessage = function (size) {\n    if (typeof size !== \"number\") {\n      throw new Error(\"Attempted to allocate an event message where size was not a number: \" + size);\n    }\n    currentMessageTotalLength = size;\n    currentMessagePendingLength = 4;\n    currentMessage = new Uint8Array(size);\n    var currentMessageView = new DataView(currentMessage.buffer);\n    currentMessageView.setUint32(0, size, false); //set big-endian Uint32 to 0~3 bytes\n  };\n\n  var iterator = function () {\n    return __asyncGenerator(this, arguments, function () {\n      var sourceIterator, _a, value, done, chunkLength, currentOffset, bytesRemaining, numBytesForTotal, numBytesToWrite;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            sourceIterator = source[Symbol.asyncIterator]();\n            _b.label = 1;\n          case 1:\n            if (!true) return [3 /*break*/, 16];\n            return [4 /*yield*/, __await(sourceIterator.next())];\n          case 2:\n            _a = _b.sent(), value = _a.value, done = _a.done;\n            if (!done) return [3 /*break*/, 10];\n            if (!!currentMessageTotalLength) return [3 /*break*/, 4];\n            return [4 /*yield*/, __await(void 0)];\n          case 3:\n            return [2 /*return*/, _b.sent()];\n          case 4:\n            if (!(currentMessageTotalLength === currentMessagePendingLength)) return [3 /*break*/, 7];\n            return [4 /*yield*/, __await(currentMessage)];\n          case 5:\n            return [4 /*yield*/, _b.sent()];\n          case 6:\n            _b.sent();\n            return [3 /*break*/, 8];\n          case 7:\n            throw new Error(\"Truncated event message received.\");\n          case 8:\n            return [4 /*yield*/, __await(void 0)];\n          case 9:\n            return [2 /*return*/, _b.sent()];\n          case 10:\n            chunkLength = value.length;\n            currentOffset = 0;\n            _b.label = 11;\n          case 11:\n            if (!(currentOffset < chunkLength)) return [3 /*break*/, 15];\n            // create new message if necessary\n            if (!currentMessage) {\n              bytesRemaining = chunkLength - currentOffset;\n              // prevent edge case where total length spans 2 chunks\n              if (!messageLengthBuffer) {\n                messageLengthBuffer = new Uint8Array(4);\n              }\n              numBytesForTotal = Math.min(4 - currentMessagePendingLength,\n              // remaining bytes to fill the messageLengthBuffer\n              bytesRemaining // bytes left in chunk\n              );\n\n              messageLengthBuffer.set(\n              // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n              value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);\n              currentMessagePendingLength += numBytesForTotal;\n              currentOffset += numBytesForTotal;\n              if (currentMessagePendingLength < 4) {\n                // not enough information to create the current message\n                return [3 /*break*/, 15];\n              }\n              allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));\n              messageLengthBuffer = null;\n            }\n            numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength,\n            // number of bytes left to complete message\n            chunkLength - currentOffset // number of bytes left in the original chunk\n            );\n\n            currentMessage.set(\n            // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n            value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);\n            currentMessagePendingLength += numBytesToWrite;\n            currentOffset += numBytesToWrite;\n            if (!(currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength)) return [3 /*break*/, 14];\n            return [4 /*yield*/, __await(currentMessage)];\n          case 12:\n            // push out the message\n            return [4 /*yield*/, _b.sent()];\n          case 13:\n            // push out the message\n            _b.sent();\n            // cleanup\n            currentMessage = null;\n            currentMessageTotalLength = 0;\n            currentMessagePendingLength = 0;\n            _b.label = 14;\n          case 14:\n            return [3 /*break*/, 11];\n          case 15:\n            return [3 /*break*/, 1];\n          case 16:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  return _a = {}, _a[Symbol.asyncIterator] = iterator, _a;\n}","map":{"version":3,"mappings":"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","names":["getChunkedStream","source","currentMessageTotalLength","currentMessagePendingLength","currentMessage","messageLengthBuffer","allocateMessage","size","Error","Uint8Array","currentMessageView","DataView","buffer","setUint32","iterator","sourceIterator","Symbol","asyncIterator","next","_a","_b","value","done","chunkLength","length","currentOffset","bytesRemaining","numBytesForTotal","Math","min","set","slice","getUint32","numBytesToWrite"],"sources":["/Workshop/product-metadata/guidance-for-generating-product-descriptions-with-bedrock/source/frontend/node_modules/@aws-sdk/eventstream-serde-universal/src/getChunkedStream.ts"],"sourcesContent":["export function getChunkedStream(source: AsyncIterable<Uint8Array>): AsyncIterable<Uint8Array> {\n  let currentMessageTotalLength = 0;\n  let currentMessagePendingLength = 0;\n  let currentMessage: Uint8Array | null = null;\n  let messageLengthBuffer: Uint8Array | null = null;\n  const allocateMessage = (size: number) => {\n    if (typeof size !== \"number\") {\n      throw new Error(\"Attempted to allocate an event message where size was not a number: \" + size);\n    }\n    currentMessageTotalLength = size;\n    currentMessagePendingLength = 4;\n    currentMessage = new Uint8Array(size);\n    const currentMessageView = new DataView(currentMessage.buffer);\n    currentMessageView.setUint32(0, size, false); //set big-endian Uint32 to 0~3 bytes\n  };\n\n  const iterator = async function* () {\n    const sourceIterator = source[Symbol.asyncIterator]();\n    while (true) {\n      const { value, done } = await sourceIterator.next();\n      if (done) {\n        if (!currentMessageTotalLength) {\n          return;\n        } else if (currentMessageTotalLength === currentMessagePendingLength) {\n          yield currentMessage as Uint8Array;\n        } else {\n          throw new Error(\"Truncated event message received.\");\n        }\n        return;\n      }\n\n      const chunkLength = value.length;\n      let currentOffset = 0;\n\n      while (currentOffset < chunkLength) {\n        // create new message if necessary\n        if (!currentMessage) {\n          // working on a new message, determine total length\n          const bytesRemaining = chunkLength - currentOffset;\n          // prevent edge case where total length spans 2 chunks\n          if (!messageLengthBuffer) {\n            messageLengthBuffer = new Uint8Array(4);\n          }\n          const numBytesForTotal = Math.min(\n            4 - currentMessagePendingLength, // remaining bytes to fill the messageLengthBuffer\n            bytesRemaining // bytes left in chunk\n          );\n\n          messageLengthBuffer.set(\n            // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n            value.slice(currentOffset, currentOffset + numBytesForTotal),\n            currentMessagePendingLength\n          );\n\n          currentMessagePendingLength += numBytesForTotal;\n          currentOffset += numBytesForTotal;\n\n          if (currentMessagePendingLength < 4) {\n            // not enough information to create the current message\n            break;\n          }\n          allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));\n          messageLengthBuffer = null;\n        }\n\n        // write data into current message\n        const numBytesToWrite = Math.min(\n          currentMessageTotalLength - currentMessagePendingLength, // number of bytes left to complete message\n          chunkLength - currentOffset // number of bytes left in the original chunk\n        );\n        currentMessage!.set(\n          // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n          value.slice(currentOffset, currentOffset + numBytesToWrite),\n          currentMessagePendingLength\n        );\n        currentMessagePendingLength += numBytesToWrite;\n        currentOffset += numBytesToWrite;\n\n        // check if a message is ready to be pushed\n        if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {\n          // push out the message\n          yield currentMessage as Uint8Array;\n          // cleanup\n          currentMessage = null;\n          currentMessageTotalLength = 0;\n          currentMessagePendingLength = 0;\n        }\n      }\n    }\n  };\n\n  return {\n    [Symbol.asyncIterator]: iterator,\n  };\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}