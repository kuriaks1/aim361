{"ast":null,"code":"import { RECONNECT_DELAY, RECONNECT_INTERVAL } from '../Providers/constants';\nexport var ReconnectEvent;\n(function (ReconnectEvent) {\n  ReconnectEvent[\"START_RECONNECT\"] = \"START_RECONNECT\";\n  ReconnectEvent[\"HALT_RECONNECT\"] = \"HALT_RECONNECT\";\n})(ReconnectEvent || (ReconnectEvent = {}));\n/**\n * Captures the reconnect event logic used to determine when to reconnect to PubSub providers.\n *   Reconnnect attempts are delayed by 5 seconds to let the interface settle.\n *   Attempting to reconnect only once creates unrecoverable states when the network state isn't\n *   supported by the browser, so this keeps retrying every minute until halted.\n */\nvar ReconnectionMonitor = /** @class */function () {\n  function ReconnectionMonitor() {\n    this.reconnectObservers = [];\n  }\n  /**\n   * Add reconnect observer to the list of observers to alert on reconnect\n   */\n  ReconnectionMonitor.prototype.addObserver = function (reconnectObserver) {\n    this.reconnectObservers.push(reconnectObserver);\n  };\n  /**\n   * Given a reconnect event, start the appropriate behavior\n   */\n  ReconnectionMonitor.prototype.record = function (event) {\n    var _this = this;\n    if (event === ReconnectEvent.START_RECONNECT) {\n      // If the reconnection hasn't been started\n      if (this.reconnectSetTimeoutId === undefined && this.reconnectIntervalId === undefined) {\n        this.reconnectSetTimeoutId = setTimeout(function () {\n          // Reconnect now\n          _this._triggerReconnect();\n          // Retry reconnect every periodically until it works\n          _this.reconnectIntervalId = setInterval(function () {\n            _this._triggerReconnect();\n          }, RECONNECT_INTERVAL);\n        }, RECONNECT_DELAY);\n      }\n    }\n    if (event === ReconnectEvent.HALT_RECONNECT) {\n      if (this.reconnectIntervalId) {\n        clearInterval(this.reconnectIntervalId);\n        this.reconnectIntervalId = undefined;\n      }\n      if (this.reconnectSetTimeoutId) {\n        clearTimeout(this.reconnectSetTimeoutId);\n        this.reconnectSetTimeoutId = undefined;\n      }\n    }\n  };\n  /**\n   * Complete all reconnect observers\n   */\n  ReconnectionMonitor.prototype.close = function () {\n    this.reconnectObservers.forEach(function (reconnectObserver) {\n      var _a;\n      (_a = reconnectObserver.complete) === null || _a === void 0 ? void 0 : _a.call(reconnectObserver);\n    });\n  };\n  ReconnectionMonitor.prototype._triggerReconnect = function () {\n    this.reconnectObservers.forEach(function (reconnectObserver) {\n      var _a;\n      (_a = reconnectObserver.next) === null || _a === void 0 ? void 0 : _a.call(reconnectObserver);\n    });\n  };\n  return ReconnectionMonitor;\n}();\nexport { ReconnectionMonitor };","map":{"version":3,"mappings":"AAGA,SAASA,eAAe,EAAEC,kBAAkB,QAAQ,wBAAwB;AAE5E,WAAYC,cAGX;AAHD,WAAYA,cAAc;EACzBA,qDAAmC;EACnCA,mDAAiC;AAClC,CAAC,EAHWA,cAAc,KAAdA,cAAc;AAK1B;;;;;;AAMA;EAAA;IACS,uBAAkB,GAAqB,EAAE;EA0DlD;EAtDC;;;EAGAC,yCAAW,GAAX,UAAYC,iBAAiC;IAC5C,IAAI,CAACC,kBAAkB,CAACC,IAAI,CAACF,iBAAiB,CAAC;EAChD,CAAC;EAED;;;EAGAD,oCAAM,GAAN,UAAOI,KAAqB;IAA5B;IACC,IAAIA,KAAK,KAAKL,cAAc,CAACM,eAAe,EAAE;MAC7C;MACA,IACC,IAAI,CAACC,qBAAqB,KAAKC,SAAS,IACxC,IAAI,CAACC,mBAAmB,KAAKD,SAAS,EACrC;QACD,IAAI,CAACD,qBAAqB,GAAGG,UAAU,CAAC;UACvC;UACAC,KAAI,CAACC,iBAAiB,EAAE;UACxB;UACAD,KAAI,CAACF,mBAAmB,GAAGI,WAAW,CAAC;YACtCF,KAAI,CAACC,iBAAiB,EAAE;UACzB,CAAC,EAAEb,kBAAkB,CAAC;QACvB,CAAC,EAAED,eAAe,CAAC;;;IAIrB,IAAIO,KAAK,KAAKL,cAAc,CAACc,cAAc,EAAE;MAC5C,IAAI,IAAI,CAACL,mBAAmB,EAAE;QAC7BM,aAAa,CAAC,IAAI,CAACN,mBAAmB,CAAC;QACvC,IAAI,CAACA,mBAAmB,GAAGD,SAAS;;MAErC,IAAI,IAAI,CAACD,qBAAqB,EAAE;QAC/BS,YAAY,CAAC,IAAI,CAACT,qBAAqB,CAAC;QACxC,IAAI,CAACA,qBAAqB,GAAGC,SAAS;;;EAGzC,CAAC;EAED;;;EAGAP,mCAAK,GAAL;IACC,IAAI,CAACE,kBAAkB,CAACc,OAAO,CAAC,2BAAiB;;MAChD,uBAAiB,CAACC,QAAQ,+CAA1BhB,iBAAiB;IAClB,CAAC,CAAC;EACH,CAAC;EAEOD,+CAAiB,GAAzB;IACC,IAAI,CAACE,kBAAkB,CAACc,OAAO,CAAC,2BAAiB;;MAChD,uBAAiB,CAACE,IAAI,+CAAtBjB,iBAAiB;IAClB,CAAC,CAAC;EACH,CAAC;EACF,0BAAC;AAAD,CAAC,CA3DD","names":["RECONNECT_DELAY","RECONNECT_INTERVAL","ReconnectEvent","ReconnectionMonitor","reconnectObserver","reconnectObservers","push","event","START_RECONNECT","reconnectSetTimeoutId","undefined","reconnectIntervalId","setTimeout","_this","_triggerReconnect","setInterval","HALT_RECONNECT","clearInterval","clearTimeout","forEach","complete","next"],"sources":["/Workshop/product-metadata/guidance-for-generating-product-descriptions-with-bedrock/source/frontend/node_modules/@aws-amplify/pubsub/src/utils/ReconnectionMonitor.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Observer } from 'zen-observable-ts';\nimport { RECONNECT_DELAY, RECONNECT_INTERVAL } from '../Providers/constants';\n\nexport enum ReconnectEvent {\n\tSTART_RECONNECT = 'START_RECONNECT',\n\tHALT_RECONNECT = 'HALT_RECONNECT',\n}\n\n/**\n * Captures the reconnect event logic used to determine when to reconnect to PubSub providers.\n *   Reconnnect attempts are delayed by 5 seconds to let the interface settle.\n *   Attempting to reconnect only once creates unrecoverable states when the network state isn't\n *   supported by the browser, so this keeps retrying every minute until halted.\n */\nexport class ReconnectionMonitor {\n\tprivate reconnectObservers: Observer<void>[] = [];\n\tprivate reconnectIntervalId?: ReturnType<typeof setInterval>;\n\tprivate reconnectSetTimeoutId?: ReturnType<typeof setTimeout>;\n\n\t/**\n\t * Add reconnect observer to the list of observers to alert on reconnect\n\t */\n\taddObserver(reconnectObserver: Observer<void>) {\n\t\tthis.reconnectObservers.push(reconnectObserver);\n\t}\n\n\t/**\n\t * Given a reconnect event, start the appropriate behavior\n\t */\n\trecord(event: ReconnectEvent) {\n\t\tif (event === ReconnectEvent.START_RECONNECT) {\n\t\t\t// If the reconnection hasn't been started\n\t\t\tif (\n\t\t\t\tthis.reconnectSetTimeoutId === undefined &&\n\t\t\t\tthis.reconnectIntervalId === undefined\n\t\t\t) {\n\t\t\t\tthis.reconnectSetTimeoutId = setTimeout(() => {\n\t\t\t\t\t// Reconnect now\n\t\t\t\t\tthis._triggerReconnect();\n\t\t\t\t\t// Retry reconnect every periodically until it works\n\t\t\t\t\tthis.reconnectIntervalId = setInterval(() => {\n\t\t\t\t\t\tthis._triggerReconnect();\n\t\t\t\t\t}, RECONNECT_INTERVAL);\n\t\t\t\t}, RECONNECT_DELAY);\n\t\t\t}\n\t\t}\n\n\t\tif (event === ReconnectEvent.HALT_RECONNECT) {\n\t\t\tif (this.reconnectIntervalId) {\n\t\t\t\tclearInterval(this.reconnectIntervalId);\n\t\t\t\tthis.reconnectIntervalId = undefined;\n\t\t\t}\n\t\t\tif (this.reconnectSetTimeoutId) {\n\t\t\t\tclearTimeout(this.reconnectSetTimeoutId);\n\t\t\t\tthis.reconnectSetTimeoutId = undefined;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Complete all reconnect observers\n\t */\n\tclose() {\n\t\tthis.reconnectObservers.forEach(reconnectObserver => {\n\t\t\treconnectObserver.complete?.();\n\t\t});\n\t}\n\n\tprivate _triggerReconnect() {\n\t\tthis.reconnectObservers.forEach(reconnectObserver => {\n\t\t\treconnectObserver.next?.();\n\t\t});\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}